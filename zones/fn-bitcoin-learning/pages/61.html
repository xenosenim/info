<!doctype html>
<html lang="en">
<head>
  <meta http-equiv='Content-Type' content='text/html; charset=UTF-8'>
  <meta name='viewport' content='width=device-width, initial-scale=1.0, user-scalable=1.0'>
  <title>Bitcoin Learning</title>
  <link rel='stylesheet' type='text/css' media='screen' href='/styles/commons.css'>
  <link rel="stylesheet" type="text/css" href="../styles/tipped.css">
  <link rel="stylesheet" type="text/css" href="../styles/jquery-ui.min.css">
  <link rel="stylesheet" type="text/css" href="../styles/tachyons.min.css">
  <link rel="stylesheet" type="text/css" href="../styles/style.css">
  <script type='text/javascript' src='/scripts/commons.js'></script>
</head>
<body>
<div id='idPanel'>
<div id='idTopbar'>
  <div id='idTopbarNavigation'>
    <a href='/'><span class='clNavHome'><span></a>
    <a href='../../index.html'><span class='clNavIndex'><span></a>
    <a href='./60.html'><span class='clNavLeft'><span></a>
    <a href='../index.html'><span class='clNavUp'><span></a>
    <a href='./62.html'><span class='clNavRight'><span></a>
  </div>
</div>

<div id='idContent'>
<h1>61.Extended Keys</h1>
<p class="subheading">Private keys and public keys that you can derive children from.</p>  <p class="bip inverse">BIP 32</p>

<p><a target='_blank' href='../images/61.extended-keys.png'><img class='clImageThumb' src='../images/61.extended-keys.png'></a><br><br></p>
<p>An <strong>extended key</strong> is a <code class="privatekey">private key</code> or <code class="publickey">public key</code> that you can use to <em>derive new keys</em> in a hierarchical deterministic wallet.</p>
<p>Therefore, you can have a single <code class="extendedprivatekey">extended private key</code>, and use it as the source for all the child <code class="privatekey">private keys</code> and <code class="publickey">public keys</code> in your wallet. In addition, a corresponding <code class="extendedpublickey">extended public key</code> will generate the same child <code class="publickey">public keys</code>.</p>

<h2>1. Master Extended Keys</h2>
<p>Your first extended keys (master keys) are created by putting a <span data-tooltip="64 bytes of entropy">seed</span> through the HMAC-SHA512 hash function.</p>
<p class="note text">
You can think of a <span data-tooltip="Hash-based Message Authentication Code">HMAC</span> as a <strong>hash function</strong> that allows you to pass data along with in an <em>additional secret key</em> to produce a new set of random bytes.
</p>

<a target='_blank' href='../images/61.master-extended-key.gif'><img class='clImageThumb' src='../images/61.master-extended-key.gif'></a><br><br>
<p class='clFigcaption'>We don’t actually need to use a key when creating our master extended keys, so we just use the arbitrary string “Bitcoin seed”<sup>1</sup>.</p>


<p>The HMAC function returns <code>64 bytes</code> of data (which is totally unpredictable). We split this in to two halves to create our master <code class="extendedprivatekey">extended private key</code>:</p>
<ul>
<li>The <strong>left half</strong> will be the <code class="privatekey">private key</code>, which is just like any other private key.</li>
<li>The <strong>right half</strong> will be the <code class="chaincode">chain code</code>, which is just an extra 32 bytes of random data.</li>
</ul>
<p class="note text">
The chain code is required for generating child keys. If you got hold of the private key but <strong><em>not</em></strong> the chain code, you wouldn’t be able to derive the <em>descendant</em> keys (thereby protecting them).
</p>

<h3>Extended Private Key</h3>
<p>So an <code class="extendedprivatekey">extended private key</code> is ultimately just a normal <code class="privatekey">private key</code> coupled with a <code class="chaincode">chain code</code>.</p>

<a target='_blank' href='../images/61.master-extended-private-key.png'><img class='clImageThumb' src='../images/61.master-extended-private-key.png'></a><br><br>
<p class='clFigcaption'>A private key with an extra 32 bytes.</p>


<h3>Extended Public Key</h3>
<p>We can also create a corresponding <code class="extendedpublickey">extended public key</code>. This just involves taking the <code class="privatekey">private key</code> and calculating its corresponding <code class="publickey">public key</code>, and coupling that with the same <code class="chaincode">chain code</code>.</p>
<p><a target='_blank' href='../images/61.master-extended-public-key.png'><img class='clImageThumb' src='../images/61.master-extended-public-key.png'></a><br><br></p>
<p>And there we have our initial master <code class="extendedprivatekey">extended private key</code> and master <code class="extendedpublickey">extended public key</code>.</p>
<p class="note tip">
<strong>Tip:</strong> As you can see, extended keys are nothing special in themselves; they are just a set of normal keys that share the same chain code (an extra 32 bytes of entropy). The real magic of extended keys is how we generate their children.
</p>
<h4>Code (Ruby)</h4>


<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span>require <span class="st">&#39;openssl&#39;</span> <span class="co"># HMAC</span></span>
<span>require <span class="st">&#39;ecdsa&#39;</span>   <span class="co"># private key to public key</span></span>
<span></span>
<span><span class="co"># ----</span></span>
<span><span class="co"># Seed</span></span>
<span><span class="co"># ----</span></span>
<span>seed = <span class="st">&quot;67f93560761e20617de26e0cb84f7234aaf373ed2e66295c3d7397e6d7ebe882ea396d5d293808b0defd7edd2babd4c091ad942e6a9351e6d075a29d4df872af&quot;</span></span>
<span>puts <span class="st">&quot;seed: </span><span class="ot">#{</span>seed<span class="ot">}</span><span class="st">&quot;</span></span>
<span>puts</span>
<span></span>
<span><span class="co"># --------------------</span></span>
<span><span class="co"># Generate Master Keys</span></span>
<span><span class="co"># --------------------</span></span>
<span><span class="co"># seed</span></span>
<span><span class="co"># |</span></span>
<span><span class="co"># m</span></span>
<span></span>
<span><span class="co"># HMAC</span></span>
<span>hmac = <span class="dt">OpenSSL</span>::<span class="dt">HMAC</span>.hexdigest(<span class="dt">OpenSSL</span>::<span class="dt">Digest</span>::<span class="dt">SHA512</span>.new, <span class="st">&quot;Bitcoin seed&quot;</span>, [seed].pack(<span class="st">&quot;H*&quot;</span>)) <span class="co"># digest, key, data</span></span>
<span>master_private_key = hmac[<span class="dv">0</span>..<span class="dv">63</span>] <span class="co"># left side of digest</span></span>
<span>master_chain_code = hmac[<span class="dv">64</span>..-<span class="dv">1</span>] <span class="co"># right side of digest</span></span>
<span></span>
<span><span class="co"># &gt; The SHA512-HMAC function is reused because it is already part of the standard elsewhere, but it takes a key in addition to the data being hashed.</span></span>
<span><span class="co"># As the key can be arbitrary, we opted to use to make sure the key derivation was Bitcoin-specific. -- Pieter Wuille</span></span>
<span></span>
<span><span class="co"># Get Public Key (multiply generator point by private key)</span></span>
<span>master_public_key = <span class="dt">ECDSA</span>::<span class="dt">Group</span>::<span class="dt">Secp256k1</span>.generator.multiply_by_scalar(master_private_key.to_i(<span class="dv">16</span>)) <span class="co"># multiply generator point by private key</span></span>
<span>master_public_key = <span class="dt">ECDSA</span>::<span class="dt">Format</span>::<span class="dt">PointOctetString</span>.encode(master_public_key, <span class="st">compression: </span><span class="dv">true</span>).unpack(<span class="st">&quot;H*&quot;</span>)[<span class="dv">0</span>] <span class="co"># encode to compressed public key format</span></span>
<span></span>
<span>puts <span class="st">&quot;master_chain_code:  </span><span class="ot">#{</span>master_chain_code<span class="ot">}</span><span class="st">&quot;</span>  <span class="co">#=&gt; 463223aac10fb13f291a1bc76bc26003d98da661cb76df61e750c139826dea8b</span></span>
<span>puts <span class="st">&quot;master_private_key: </span><span class="ot">#{</span>master_private_key<span class="ot">}</span><span class="st">&quot;</span> <span class="co">#=&gt; f79bb0d317b310b261a55a8ab393b4c8a1aba6fa4d08aef379caba502d5d67f9</span></span>
<span>puts <span class="st">&quot;master_public_key:  </span><span class="ot">#{</span>master_public_key<span class="ot">}</span><span class="st">&quot;</span>  <span class="co">#=&gt; 0252c616d91a2488c1fd1f0f172e98f7d1f6e51f8f389b2f8d632a8b490d5f6da9</span></span></code></pre>

</div>
<h2>2. Extended Key Tree</h2>
<p>All extended keys can derive <em>child extended keys</em>.</p>
<ul>
<li><strong><code class="extendedprivatekey">extended private keys</code></strong> can generate child keys with new <code class="privatekey">private keys</code> and <code class="publickey">public keys</code>.</li>
<li><strong><code class="extendedpublickey">extended public keys</code></strong> can generate child keys with new <code class="publickey">public keys</code> only.</li>
</ul>
<p>Each child also has an <em>index</em> number (up to <code class="numbers tooltip" data-tooltip="4294967296">2**32</code>).</p>



<a target='_blank' href='../images/61.extended-key-tree.png'><img class='clImageThumb' src='../images/61.extended-key-tree.png'></a><br><br>
<p class='clFigcaption'>The cool thing about extended public keys is that they can generate the same public keys as the extended private key.</p>


<p>For security, you can derive two types of children from an <strong><code class="extendedprivatekey">extended private key</code></strong>:</p>
<ol type="1">
<li><strong>Normal</strong> - The <code class="extendedprivatekey">extended private key</code> and <code class="extendedpublickey">extended public key</code> can generate the same <code class="publickey">public key</code>.<br><small>Indexes <code class="numbers">0</code> to <code class="numbers">2147483647</code> (the first half of all possible children)</small></li>
<li><strong>Hardened</strong> - Only the <code class="extendedprivatekey">extended private key</code> can generate the <code class="publickey">public key</code>.<br><small>Indexes <code class="numbers">2147483648</code> to <code class="numbers">4294967295</code> (the last half of all possible children)</small></li>
</ol>
<p>In other words, a hardened child gives you the option of creating a “secret” or “internal” public key, as the extended public key cannot derive them.</p>
<h2>3. Child Extended Key Derivation</h2>
<p>Both <code class="extendedprivatekey">extended private keys</code> and <code class="extendedpublickey">extended public keys</code> can derive children, each with their own unique <code class="numbers">index</code> number.</p>
<p>There are 3 methods for deriving child keys:</p>
<ol type="1">
<li><em>Normal</em> Child <code class="extendedprivatekey">extended private key</code></li>
<li><em>Hardened</em> Child <code class="extendedprivatekey">extended private key</code></li>
<li><em>Normal</em> Child <code class="extendedpublickey">extended public key</code></li>
</ol>
<p class="note tip">
<strong>Tip:</strong> Derived child extended keys (and parent keys) are independent of each other. In other words, you wouldn’t know that two public keys in an extended tree are connected in any way.
</p>
<h3>1. <em>Normal</em> Child <code class="extendedprivatekey">extended private key</code></h3>

<a target='_blank' href='../images/61.child-extended-private-key-normal.png'><img class='clImageThumb' src='../images/61.child-extended-private-key-normal.png'></a><br><br>
<p class='clFigcaption'><small>“Scalar addition” just means to traditional arithmetic addition.</small></p>



<ol type="1">
<li><strong>Work out the public key.</strong> (This is so a corresponding extended public key can put the same data in to the HMAC function when deriving their children.)</li>
<li><strong>Use an index between <code class="numbers">0</code> and <code class="numbers">2147483647</code>.</strong> Indexes in this range are designated for <em>normal</em> child extended keys.</li>
<li><strong>Put data and key through HMAC.</strong>
<ul>
<li><em>data</em> = <code class="publickey">public key</code>+<code class="numbers">index</code> (<span data-tooltip="Joined together">concatenated</code>)</li>
<li><em>key</em> = <code class="chaincode">chain code</code></li>
</ul></li>
</ol>
<p>The <strong>new chain code</strong> is the last 32 bytes of the result from the HMAC. This is just a unique set of bytes that we can use for the new chain code.</p>
<p>The <strong>new private key</strong> is the first 32 bytes of the result from the HMAC added to the original private key. This essentially just takes the original private key and <em>increases</em> it by a random 32-byte number. We modulus the new <strong>private key</strong> by the <span data-tooltip="n = 115792089237316195423570985008687907852837564279074904382605163141518161494337">order of the curve</span> to keep the new private key within the valid range of numbers for the elliptic curve.</p>
<p>So in summary, we use the data inside the parent extended private key (<code class="publickey">public key</code>+<code class="numbers">index</code>, <code class="chaincode">chain code</code>) and put it through the HMAC function to produce some new random bytes. We use these new random bytes to construct the next private key from the old one.</p>

<h4>Code (Ruby)</h4>


<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span>require <span class="st">&#39;openssl&#39;</span> <span class="co"># HMAC</span></span>
<span>require <span class="st">&#39;ecdsa&#39;</span>   <span class="co"># private key to public key</span></span>
<span></span>
<span><span class="co"># ---------------------------------</span></span>
<span><span class="co"># Normal Child Extended Private Key</span></span>
<span><span class="co"># ---------------------------------</span></span>
<span><span class="co"># m</span></span>
<span><span class="co"># |- m/0</span></span>
<span><span class="co"># |- m/1</span></span>
<span><span class="co"># |- m/2</span></span>
<span><span class="co"># ...</span></span>
<span></span>
<span>parent_chain_code  = <span class="st">&quot;463223aac10fb13f291a1bc76bc26003d98da661cb76df61e750c139826dea8b&quot;</span></span>
<span>parent_private_key = <span class="st">&quot;f79bb0d317b310b261a55a8ab393b4c8a1aba6fa4d08aef379caba502d5d67f9&quot;</span></span>
<span>parent_public_key  = <span class="st">&quot;0252c616d91a2488c1fd1f0f172e98f7d1f6e51f8f389b2f8d632a8b490d5f6da9&quot;</span></span>
<span>i = <span class="dv">0</span> <span class="co"># child index number</span></span>
<span></span>
<span><span class="co"># Prepare data and key to put through HMAC function</span></span>
<span>data = [parent_public_key].pack(<span class="st">&quot;H*&quot;</span>) + [i].pack(<span class="st">&quot;N&quot;</span>) <span class="co"># public key + index</span></span>
<span>key = [parent_chain_code].pack(<span class="st">&quot;H*&quot;</span>) <span class="co"># chain code is key for hmac</span></span>
<span></span>
<span>hmac = <span class="dt">OpenSSL</span>::<span class="dt">HMAC</span>.hexdigest(<span class="dt">OpenSSL</span>::<span class="dt">Digest</span>::<span class="dt">SHA512</span>.new, key, data) <span class="co"># digest, key, data</span></span>
<span>il = hmac[<span class="dv">0</span>..<span class="dv">63</span>]  <span class="co"># left side of intermediate key [32 bytes]</span></span>
<span>ir = hmac[<span class="dv">64</span>..-<span class="dv">1</span>] <span class="co"># right side of intermediate key [32 bytes]</span></span>
<span></span>
<span><span class="co"># Chain code is last 32 bytes</span></span>
<span>child_chain_code = ir</span>
<span></span>
<span><span class="co"># Check the chain code is valid.</span></span>
<span><span class="kw">if</span> child_chain_code.to_i(<span class="dv">16</span>) &gt;= <span class="dt">ECDSA</span>::<span class="dt">Group</span>::<span class="dt">Secp256k1</span>.order</span>
<span>    raise <span class="st">&quot;Chain code is greater than the order of the curve. Try the next index.&quot;</span></span>
<span><span class="kw">end</span></span>
<span></span>
<span><span class="co"># Calculate child private key</span></span>
<span>child_private_key = (il.to_i(<span class="dv">16</span>) + parent_private_key.to_i(<span class="dv">16</span>)) % <span class="dt">ECDSA</span>::<span class="dt">Group</span>::<span class="dt">Secp256k1</span>.order <span class="co"># (il + parent_key) % n</span></span>
<span>child_private_key = child_private_key.to_s(<span class="dv">16</span>).rjust(<span class="dv">64</span>, <span class="ch">&#39;0&#39;</span>) <span class="co"># convert to hex (and make sure it&#39;s 32 bytes long)</span></span>
<span></span>
<span><span class="co"># Work out the corresponding public key too (optional)</span></span>
<span>child_public_key = <span class="dt">ECDSA</span>::<span class="dt">Group</span>::<span class="dt">Secp256k1</span>.generator.multiply_by_scalar(child_private_key.to_i(<span class="dv">16</span>)) <span class="co"># work out the public key for this too</span></span>
<span>child_public_key = <span class="dt">ECDSA</span>::<span class="dt">Format</span>::<span class="dt">PointOctetString</span>.encode(child_public_key, <span class="st">compression: </span><span class="dv">true</span>).unpack(<span class="st">&quot;H*&quot;</span>)[<span class="dv">0</span>] <span class="co"># encode to compressed public key format</span></span>
<span></span>
<span><span class="co"># Results</span></span>
<span>puts <span class="st">&quot;child_chain_code:   </span><span class="ot">#{</span>child_chain_code<span class="ot">}</span><span class="st">&quot;</span>  <span class="co">#=&gt; 05aae71d7c080474efaab01fa79e96f4c6cfe243237780b0df4bc36106228e31</span></span>
<span>puts <span class="st">&quot;child_private_key:  </span><span class="ot">#{</span>child_private_key<span class="ot">}</span><span class="st">&quot;</span> <span class="co">#=&gt; 39f329fedba2a68e2a804fcd9aeea4104ace9080212a52ce8b52c1fb89850c72</span></span>
<span>puts <span class="st">&quot;child_public_key:   </span><span class="ot">#{</span>child_public_key<span class="ot">}</span><span class="st">&quot;</span>  <span class="co">#=&gt; 030204d3503024160e8303c0042930ea92a9d671de9aa139c1867353f6b6664e59</span></span></code></pre>

</div>
<h3>2. <em>Hardened</em> Child <code class="extendedprivatekey">extended private key</code></h3>
<p><a target='_blank' href='../images/61.child-extended-private-key-hardened.png'><img class='clImageThumb' src='../images/61.child-extended-private-key-hardened.png'></a><br><br></p>
<ol type="1">
<li><strong>Use an index between <code class="numbers">2147483647</code> and <code class="numbers">4294967295</code>.</strong> Indexes in this range are designated for hardened child extended keys.</li>
<li><strong>Put data and key through HMAC.</strong>
<ul>
<li><em>data</em> = <code class="privatekey">private key</code>+<code class="numbers">index</code> (concatenated)</li>
<li><em>key</em> = <code class="chaincode">chain code</code></li>
</ul></li>
</ol>
<p>The <strong>new chain code</strong> is the last 32 bytes of the result from the HMAC.</p>
<p>The <strong>new private key</strong> is the first 32 bytes of the result from the HMAC added to the original private key. This again just takes the original private key and <em>increases</em> it by a random 32-byte number.</p>
<p>However, this hardened child key was constructed by putting the <strong>private key</strong> in to the HMAC function (which an extended public key does not have access to), which means that child extended private keys derived in this way will have a public key that cannot be derived by a corresponding extended public key.</p>
<blockquote>
<p>Hardened derivation should be the default unless there is a good reason why you need to be able to generate public keys without access to the private key. – Pieter Wuille<sup>2</sup></p>
</blockquote>
<h4>Code (Ruby)</h4>


<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span>require <span class="st">&#39;openssl&#39;</span> <span class="co"># HMAC</span></span>
<span>require <span class="st">&#39;ecdsa&#39;</span>   <span class="co"># private key to public key</span></span>
<span></span>
<span><span class="co"># -----------------------------------</span></span>
<span><span class="co"># Hardened Child Extended Private Key</span></span>
<span><span class="co"># -----------------------------------</span></span>
<span><span class="co"># m</span></span>
<span><span class="co"># ...</span></span>
<span><span class="co"># |- m/2147483648</span></span>
<span><span class="co"># |- m/2147483649</span></span>
<span><span class="co"># |- m/2147483650</span></span>
<span><span class="co"># ...</span></span>
<span></span>
<span>parent_chain_code  = <span class="st">&quot;463223aac10fb13f291a1bc76bc26003d98da661cb76df61e750c139826dea8b&quot;</span></span>
<span>parent_private_key = <span class="st">&quot;f79bb0d317b310b261a55a8ab393b4c8a1aba6fa4d08aef379caba502d5d67f9&quot;</span></span>
<span>i = <span class="dv">2147483648</span> <span class="co"># child index number (must between 2**31 and 2**32-1)</span></span>
<span></span>
<span><span class="co"># Prepare data and key to put through HMAC function</span></span>
<span>data = [<span class="st">&quot;00&quot;</span>].pack(<span class="st">&quot;H*&quot;</span>) + [parent_private_key].pack(<span class="st">&quot;H*&quot;</span>) + [i].pack(<span class="st">&quot;N&quot;</span>)  <span class="co"># 0x00 + private_key + index</span></span>
<span>key = [parent_chain_code].pack(<span class="st">&quot;H*&quot;</span>) <span class="co"># chain code is key for hmac</span></span>
<span></span>
<span>hmac = <span class="dt">OpenSSL</span>::<span class="dt">HMAC</span>.hexdigest(<span class="dt">OpenSSL</span>::<span class="dt">Digest</span>::<span class="dt">SHA512</span>.new, key, data) <span class="co"># digest, key, data</span></span>
<span>il = hmac[<span class="dv">0</span>..<span class="dv">63</span>]  <span class="co"># left side of intermediate key [32 bytes]</span></span>
<span>ir = hmac[<span class="dv">64</span>..-<span class="dv">1</span>] <span class="co"># right side of intermediate key [32 bytes]</span></span>
<span></span>
<span><span class="co"># Chain code is last 32 bytes</span></span>
<span>child_chain_code = ir</span>
<span></span>
<span><span class="co"># Check the chain code is valid.</span></span>
<span><span class="kw">if</span> child_chain_code.to_i(<span class="dv">16</span>) &gt;= <span class="dt">ECDSA</span>::<span class="dt">Group</span>::<span class="dt">Secp256k1</span>.order</span>
<span>    raise <span class="st">&quot;Chain code is greater than the order of the curve. Try the next index.&quot;</span></span>
<span><span class="kw">end</span></span>
<span></span>
<span><span class="co"># Calculate child private key</span></span>
<span>child_private_key = (il.to_i(<span class="dv">16</span>) + parent_private_key.to_i(<span class="dv">16</span>)) % <span class="dt">ECDSA</span>::<span class="dt">Group</span>::<span class="dt">Secp256k1</span>.order <span class="co"># (il + parent_key) % n</span></span>
<span>child_private_key = child_private_key.to_s(<span class="dv">16</span>).rjust(<span class="dv">64</span>, <span class="ch">&#39;0&#39;</span>) <span class="co"># convert to hex (and make sure it&#39;s 32 bytes long)</span></span>
<span></span>
<span><span class="co"># Work out the corresponding public key too (optional)</span></span>
<span>child_public_key = <span class="dt">ECDSA</span>::<span class="dt">Group</span>::<span class="dt">Secp256k1</span>.generator.multiply_by_scalar(child_private_key.to_i(<span class="dv">16</span>)) <span class="co"># work out the public key for this too</span></span>
<span>child_public_key = <span class="dt">ECDSA</span>::<span class="dt">Format</span>::<span class="dt">PointOctetString</span>.encode(child_public_key, <span class="st">compression: </span><span class="dv">true</span>).unpack(<span class="st">&quot;H*&quot;</span>)[<span class="dv">0</span>] <span class="co"># encode to compressed public key format</span></span>
<span></span>
<span>puts <span class="st">&quot;child_chain_code:   </span><span class="ot">#{</span>child_chain_code<span class="ot">}</span><span class="st">&quot;</span>  <span class="co">#=&gt; cb3c17166cc30eb7fdd11993fb7307531372e565cd7c7136cbfa4655622bc2be</span></span>
<span>puts <span class="st">&quot;child_private_key:  </span><span class="ot">#{</span>child_private_key<span class="ot">}</span><span class="st">&quot;</span> <span class="co">#=&gt; 7272904512add56fef94c7b4cfc62bedd0632afbad680f2eb404e95f2d84cbfa</span></span>
<span>puts <span class="st">&quot;child_public_key:   </span><span class="ot">#{</span>child_public_key<span class="ot">}</span><span class="st">&quot;</span>  <span class="co">#=&gt; 0355cff4a963ce259b08be9a864564caca210eb4eb35fcb75712e4bba7550efd95</span></span></code></pre>

</div>
<h3>3. <em>Normal</em> Child <code class="extendedpublickey">extended public key</code></h3>
<p><a target='_blank' href='../images/61.child-extended-public-key-normal.png'><img class='clImageThumb' src='../images/61.child-extended-public-key-normal.png'></a><br><br></p>
<ol type="1">
<li><strong>Use an index between <code class="numbers">0</code> and <code class="numbers">2147483647</code>.</strong> Indexes in this range are designated for <em>normal</em> child extended keys.</li>
<li><strong>Put data and key through HMAC.</strong>
<ul>
<li><em>data</em> = <code class="publickey">public key</code>+<code class="numbers">index</code> (concatenated)</li>
<li><em>key</em> = <code class="chaincode">chain code</code></li>
</ul></li>
</ol>
<p>The <strong>new chain code</strong> is the last 32 bytes of the result from the HMAC. This will be the same chain code as the <em>normal</em> child extended private key above, because if you look back you will see that we put the same inputs in to the HMAC function.</p>
<p>The <strong>new public key</strong> is the original public key point added to the first 32 bytes of the result of the HMAC as a point on the curve (multiply by the generator to get this as a pont).</p>
<p>So in summary, we put the same data and key in to the HMAC function as we did when generating the child extended private key. We can then work out the child <code class="publickey">public key</code> via elliptic curve point addition with the same first 32 bytes of the HMAC result (which means it corresponds to the <code class="privatekey">private key</code> in the child <code class="extendedprivatekey">extended private key</code>).</p>
<h4>Code (Ruby)</h4>


<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span>require <span class="st">&#39;openssl&#39;</span> <span class="co"># HMAC</span></span>
<span>require <span class="st">&#39;ecdsa&#39;</span></span>
<span></span>
<span><span class="co"># --------------------------------</span></span>
<span><span class="co"># Normal Child Extended Public Key</span></span>
<span><span class="co"># --------------------------------</span></span>
<span><span class="co"># m -------- p</span></span>
<span><span class="co">#            |- p/0</span></span>
<span><span class="co">#            |- p/1</span></span>
<span><span class="co">#            |- p/3</span></span>
<span></span>
<span>parent_chain_code = <span class="st">&quot;463223aac10fb13f291a1bc76bc26003d98da661cb76df61e750c139826dea8b&quot;</span></span>
<span>parent_public_key = <span class="st">&quot;0252c616d91a2488c1fd1f0f172e98f7d1f6e51f8f389b2f8d632a8b490d5f6da9&quot;</span></span>
<span>i = <span class="dv">0</span> <span class="co"># child index number</span></span>
<span></span>
<span><span class="kw">if</span> i &gt;= <span class="dv">2</span>**<span class="dv">31</span></span>
<span>    raise <span class="st">&quot;Can&#39;t create hardened child public keys from parent public keys.&quot;</span></span>
<span><span class="kw">end</span></span>
<span></span>
<span><span class="co"># Prepare data and key to put through HMAC function</span></span>
<span>key = [parent_chain_code].pack(<span class="st">&quot;H*&quot;</span>)</span>
<span>data = [parent_public_key].pack(<span class="st">&quot;H*&quot;</span>) + [i].pack(<span class="st">&quot;N&quot;</span>) <span class="co"># 32-bit unsigned, network (big-endian) byte order</span></span>
<span></span>
<span>hmac = <span class="dt">OpenSSL</span>::<span class="dt">HMAC</span>.hexdigest(<span class="dt">OpenSSL</span>::<span class="dt">Digest</span>::<span class="dt">SHA512</span>.new, key, data)</span>
<span>il = hmac[<span class="dv">0</span>..<span class="dv">63</span>]  <span class="co"># left side of intermediate key [32 bytes]</span></span>
<span>ir = hmac[<span class="dv">64</span>..-<span class="dv">1</span>] <span class="co"># right side of intermediate key [32 bytes]</span></span>
<span></span>
<span><span class="co"># Chain code is last 32 bytes</span></span>
<span>child_chain_code = hmac[<span class="dv">64</span>..-<span class="dv">1</span>]</span>
<span></span>
<span><span class="kw">if</span> il.to_i(<span class="dv">16</span>) &gt;= <span class="dt">ECDSA</span>::<span class="dt">Group</span>::<span class="dt">Secp256k1</span>.order</span>
<span>    raise <span class="st">&quot;Result of digest is greater than the order of the curve. Try the next index.&quot;</span></span>
<span><span class="kw">end</span></span>
<span></span>
<span><span class="co"># Work out the child public key</span></span>
<span>point_hmac   = <span class="dt">ECDSA</span>::<span class="dt">Group</span>::<span class="dt">Secp256k1</span>.generator.multiply_by_scalar(il.to_i(<span class="dv">16</span>))                               <span class="co"># convert hmac il to a point</span></span>
<span>point_public = <span class="dt">ECDSA</span>::<span class="dt">Format</span>::<span class="dt">PointOctetString</span>.decode([parent_public_key].pack(<span class="st">&quot;H*&quot;</span>), <span class="dt">ECDSA</span>::<span class="dt">Group</span>::<span class="dt">Secp256k1</span>) <span class="co"># convert parent_public_key to a point</span></span>
<span>point = point_hmac.add_to_point(point_public)                                                                  <span class="co"># point addition</span></span>
<span></span>
<span><span class="kw">if</span> (point == <span class="dt">ECDSA</span>::<span class="dt">Group</span>::<span class="dt">Secp256k1</span>.infinity)</span>
<span>    raise <span class="st">&quot;Child public key point is at point of infinitiy. Try the next index.&quot;</span></span>
<span><span class="kw">end</span></span>
<span></span>
<span>child_public_key = <span class="dt">ECDSA</span>::<span class="dt">Format</span>::<span class="dt">PointOctetString</span>.encode(point, <span class="st">compression: </span><span class="dv">true</span>).unpack(<span class="st">&quot;H*&quot;</span>)[<span class="dv">0</span>] <span class="co"># encode to compress public key</span></span>
<span></span>
<span>puts <span class="st">&quot;child_chain_code:   </span><span class="ot">#{</span>child_chain_code<span class="ot">}</span><span class="st">&quot;</span></span>
<span>puts <span class="st">&quot;child_public_key:   </span><span class="ot">#{</span>child_public_key<span class="ot">}</span><span class="st">&quot;</span></span></code></pre>

</div>
<h3>4. <em>Hardened</em> Child <code class="extendedpublickey">extended public key</code></h3>
<p><em>Not possible.</em></p>
<h2>4. Why does this work?</h2>
<p>In other words, how is it possible that a <code class="publickey">public key</code> derived from an <code class="extendedpublickey">extended public key</code> corresponds to a <code class="privatekey">private key</code> derived from an <code class="extendedprivatekey">extended private key</code>?</p>
<p>Well, for both child extended keys, we are putting the <em>same inputs</em> in the HMAC function, so we’re getting the same data as a result. Using the first 32 bytes of this data (which is basically a number) we then:</p>
<ul>
<li><em>Increase</em> the parent <code class="privatekey">private key</code> by this number to create the <strong>child</strong> <code class="privatekey">private key</code>.</li>
<li><em>Increase</em> the parent <code class="publickey">public key</code> by the same amount to create the <strong>child</strong> <code class="publickey">public key</code>.</li>
</ul>
<p>And due to the way elliptic curve mathematics works, the child <code class="privatekey">private key</code> will correspond to the child <code class="publickey">public key</code>.</p>
<p><a target='_blank' href='../images/61.why-it-works.png'><img class='clImageThumb' src='../images/61.why-it-works.png'></a><br><br></p>
<h3>Come again?</h3>


<p>First of all, remember that a <strong>public key</strong> is just the <strong>generator point</strong> on an elliptic curve <strong>multiplied by a private key</strong>:</p>
<p><a target='_blank' href='../images/61.ecc-multiply.png'><img class='clImageThumb' src='../images/61.ecc-multiply.png'></a><br><br></p>
<p>Now, if you increase this private key by a <strong>number</strong> (i.e. the first 32 bytes of the HMAC result) we get a new private key. When you multiply this new private key by the generator point, we get the new public key:</p>
<p><a target='_blank' href='../images/61.ecc-extended-private-key-public-key.png'><img class='clImageThumb' src='../images/61.ecc-extended-private-key-public-key.png'></a><br><br></p>
<p>Similarly, if you take the original public key and add that same <strong>number</strong> to it (as a point on the curve), you end up with the same new public key as above:</p>
<p><a target='_blank' href='../images/61.ecc-extended-public-key-public-key.png'><img class='clImageThumb' src='../images/61.ecc-extended-public-key-public-key.png'></a><br><br></p>
<h3>Code (Ruby)</h3>
<div class="showhide">
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span>require <span class="st">&#39;ecdsa&#39;</span>   <span class="co"># (ECDSA Math) sudo gem install ecdsa</span></span>
<span></span>
<span><span class="co"># Original Private Key and Public Key</span></span>
<span>private_key = <span class="dv">12345</span></span>
<span>public_key  = <span class="dt">ECDSA</span>::<span class="dt">Group</span>::<span class="dt">Secp256k1</span>.generator.multiply_by_scalar(private_key)</span>
<span>number = rand(<span class="dv">1000000</span>) <span class="co"># used to modify the private key and public key independently</span></span>
<span></span>
<span><span class="co"># Child Public Key 1: (Private Key + Number) * Generator</span></span>
<span>private_and_number = private_key + number</span>
<span>child_public_key1  = <span class="dt">ECDSA</span>::<span class="dt">Group</span>::<span class="dt">Secp256k1</span>.generator.multiply_by_scalar(private_and_number)</span>
<span></span>
<span><span class="co"># Child Public Key 2: Public Key + (Number * Generator)</span></span>
<span>number_point       = <span class="dt">ECDSA</span>::<span class="dt">Group</span>::<span class="dt">Secp256k1</span>.generator.multiply_by_scalar(number)</span>
<span>child_public_key2  = public_key.add_to_point(number_point)</span>
<span></span>
<span><span class="co"># Results</span></span>
<span>puts <span class="dt">ECDSA</span>::<span class="dt">Format</span>::<span class="dt">PointOctetString</span>.encode(child_public_key1, <span class="st">compression: </span><span class="dv">true</span>).unpack(<span class="st">&quot;H*&quot;</span>) <span class="co">#=&gt; e.g. 022861a4809b2d8eb9269abea605f47db91deb9f5385bcc10b94aac6a0b81cba3d</span></span>
<span>puts <span class="dt">ECDSA</span>::<span class="dt">Format</span>::<span class="dt">PointOctetString</span>.encode(child_public_key2, <span class="st">compression: </span><span class="dv">true</span>).unpack(<span class="st">&quot;H*&quot;</span>) <span class="co">#=&gt; e.g. 022861a4809b2d8eb9269abea605f47db91deb9f5385bcc10b94aac6a0b81cba3d</span></span>
<span>puts child_public_key1 == child_public_key2 <span class="co">#=&gt; true</span></span></code></pre>

</div>
</div>
<h3>Security Note</h3>


<p>Due to the way <strong>normal</strong> child keys are derived, if you have a <code class="extendedpublickey">extended public key</code> <strong>and</strong> any child <code class="privatekey">private key</code>, it’s possible to work out the parent <code class="extendedprivatekey">extended private key</code>.</p>
<p><a target='_blank' href='../images/61.weakness.png'><img class='clImageThumb' src='../images/61.weakness.png'></a><br><br></p>

<p>In other words, if your <code class="extendedpublickey">extended public key</code> is publicly known, be <em>very</em> careful not to reveal a child <code class="privatekey">private key</code>. If you do, anyone can work backwards to calculate the <code class="extendedprivatekey">extended private key</code> and steal the bitcoins from <strong>all the child keys</strong> at that level in the tree.</p>
<p class="note tip">
<strong>Tip:</strong> This is why <strong>hardened</strong> children are useful, because losing a child private key at one level in the tree will never leave the other child private keys at risk of being derived.
</p>
<h3>Code (Ruby)</h3>
<div class="showhide">
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span>require <span class="st">&#39;openssl&#39;</span></span>
<span></span>
<span><span class="co"># ------</span></span>
<span><span class="co"># Secret</span></span>
<span><span class="co"># ------</span></span>
<span>parent_private_key = <span class="st">&quot;081549973bafbba825b31bcc402a3c4ed8e3185c2f3a31c75e55f423e9629aa3&quot;</span></span>
<span></span>
<span><span class="co"># --------------------</span></span>
<span><span class="co"># Revealed Information</span></span>
<span><span class="co"># --------------------</span></span>
<span></span>
<span><span class="co"># parent extended public key</span></span>
<span>parent_public_key = <span class="st">&quot;0343b337dec65a47b3362c9620a6e6ff39a1ddfa908abab1666c8a30a3f8a7cccc&quot;</span></span>
<span>parent_chain_code = <span class="st">&quot;1d7d2a4c940be028b945302ad79dd2ce2afe5ed55e1a2937a5af57f8401e73dd&quot;</span></span>
<span></span>
<span><span class="co"># child private key</span></span>
<span>child_private_key = <span class="st">&quot;c41cd73a9df26db3bccfad12e9bbe66d4d619b6c9510f43a618fbef27fa78ce4&quot;</span> <span class="co"># index=0</span></span>
<span></span>
<span><span class="co"># ------------------------------------------</span></span>
<span><span class="co"># We can now work out the parent private key</span></span>
<span><span class="co"># ------------------------------------------</span></span>
<span></span>
<span><span class="co"># 1. Get the left side of the HMAC from the parent extended public key</span></span>
<span>key  = [parent_chain_code].pack(<span class="st">&quot;H*&quot;</span>)</span>
<span>data = [parent_public_key].pack(<span class="st">&quot;H*&quot;</span>) + [<span class="dv">0</span>].pack(<span class="st">&quot;N&quot;</span>) <span class="co"># the 0 refers to the same index as the child private key</span></span>
<span>hmac = <span class="dt">OpenSSL</span>::<span class="dt">HMAC</span>.hexdigest(<span class="dt">OpenSSL</span>::<span class="dt">Digest</span>::<span class="dt">SHA512</span>.new, key, data)</span>
<span>hmac_left = hmac[<span class="dv">0</span>..<span class="dv">63</span>]</span>
<span></span>
<span><span class="co"># 2. Calculate the parent private key (child private key minus the hmac left)</span></span>
<span>n = <span class="dv">115792089237316195423570985008687907852837564279074904382605163141518161494337</span> <span class="co"># order of the curve</span></span>
<span>calculated_key = (child_private_key.to_i(<span class="dv">16</span>) - hmac_left.to_i(<span class="dv">16</span>)) % n</span>
<span></span>
<span><span class="co"># -------</span></span>
<span><span class="co"># Results</span></span>
<span><span class="co"># -------</span></span>
<span>puts <span class="st">&quot;parent private key: </span><span class="ot">#{</span>parent_private_key.to_i(<span class="dv">16</span>)<span class="ot">}</span><span class="st">&quot;</span></span>
<span>puts</span>
<span>puts <span class="st">&quot;child private key:  </span><span class="ot">#{</span>child_private_key.to_i(<span class="dv">16</span>)<span class="ot">}</span><span class="st">&quot;</span></span>
<span>puts <span class="st">&quot;hmac left:          </span><span class="ot">#{</span>hmac_left.to_i(<span class="dv">16</span>)<span class="ot">}</span><span class="st">&quot;</span></span>
<span>puts <span class="st">&quot;calculated:         </span><span class="ot">#{</span>calculated_key<span class="ot">}</span><span class="st">&quot;</span> <span class="co">#=&gt; 081549973bafbba825b31bcc402a3c4ed8e3185c2f3a31c75e55f423e9629aa3</span></span></code></pre>

</div>
</div>
<h2>5. Serialization</h2>
<p>An extended key can be serialized to make it easier to pass around. This serialized data contains the <code class="privatekey">private key</code>/<code class="publickey">public key</code> and <code class="chaincode">chain code</code>, along with some additional <span data-tooltip="Data that describes other data, serving as an informative label.">metadata</span>.</p>
<p><a target='_blank' href='../images/61.serialized-extended-key.png'><img class='clImageThumb' src='../images/61.serialized-extended-key.png'></a><br><br></p>
<p>A serialized key contains the following fields:</p>
<table>
<tr>
<td class="bytes">
4 bytes</td>
<td class="code">
<strong>Version</strong></td>
<td class="text">
Places “xprv” <code>0488ade4</code> or “xpub” <code>0488b21e</code> at the start.</td>
</tr>
<tr>
<td class="bytes">
1 byte</td>
<td class="code">
<strong>Depth</strong></td>
<td class="text">
How many derivations deep this extended key is from the <strong>master key</strong>.</td>
</tr>
<tr>
<td class="bytes">
4 bytes</td>
<td class="code">
<strong>Parent Fingerprint</strong></td>
<td class="text">
The first 4 bytes of the hash160 of the parent’s <em>public</em> key. This helps to identify the parent later.</td>
</tr>
<tr>
<td class="bytes">
4 bytes</td>
<td class="code">
<strong>Child Number</strong></td>
<td class="text">
The <em>index</em> number of this child from the parent.</td>
</tr>
<tr>
<td class="bytes">
32 bytes</td>
<td class="code">
<strong>Chain Code</strong></td>
<td class="text">
The extra 32 byte secret. This prevents others from deriving child keys without it.</td>
</tr>
<tr>
<td class="bytes">
33 bytes</td>
<td class="code">
<strong>Key</strong></td>
<td class="text">
The <code class="privatekey">private key</code> (prepend <code class="bytes">0x00</code>) or <code class="publickey">public key</code>.</td>
</tr>
<tr>
<td colspan="3" style="padding:0px; font-size:0.8em">
<details style="margin-bottom:0px">
<summary>
Notes
</summary>
<p class="note text">
<strong>Version Bytes</strong>:<br> <code>0488ade4</code> = xprv<br> <code>0488b21e</code> = xpub<br> <code>049d7878</code> = yprv <span class="grey">(for extended keys in a BIP 49 derivation path)</span><br> <code>049d7cb2</code> = ypub<br> <code>04b2430c</code> = zprv <span class="grey">(for extended keys in a BIP 84 derivation path)</span><br> <code>04b24746</code> = zpub<br>
</p>
<p class="note text">
<strong>Master Extended Keys</strong>:<br>Depth = <code class="bytes">00</code><br>Fingerprint = <code class="bytes">00000000</code><br>Child Number = <code class="bytes">00000000</code>
</p>
<p class="note tip">
In the <strong><span class="monospace">Key<span></strong> field, a <code class="privatekey">private key</code> (32 bytes) is prepended with <code class="bytes">0x00</code> to extend it to the <em>same length</em> as a <code class="publickey">public key</code> (33 bytes).
</p>
</details></td>
</tr>
</table>
<p>A checksum is then added to this data (to help detect errors), before finally converting everything to Base58 (to create a human-friendly extended key format).</p>
<p>An <code class="extendedprivatekey">extended private key</code> looks like this:</p>
<pre class="address"><code>xprv9tuogRdb5YTgcL3P8Waj7REqDuQx4sXcodQaWTtEVFEp6yRKh1CjrWfXChnhgHeLDuXxo2auDZegMiVMGGxwxcrb2PmiGyCngLxvLeGsZRq</code></pre>
<p>An <code class="extendedpublickey">extended public key</code> looks like this:</p>
<pre class="address"><code>xpub67uA5wAUuv1ypp7rEY7jUZBZmwFSULFUArLBJrHr3amnymkUEYWzQJz13zLacZv33sSuxKVmerpZeFExapBNt8HpAqtTtWqDQRAgyqSKUHu</code></pre>
<p>As you can see they’re pretty long, but that’s because they contain extra useful information about the extended key.</p>
<p class="note tip">
<strong>Tip:</strong> The <em>fingerprint</em>, <em>depth</em>, and <em>child number</em> are not required for deriving child extended keys – they just help you to identify the current key’s parent and position in the tree.
</p>
<p class="note text">
<strong>Note:</strong> The 4-byte field for the <em>child number</em> is the reason why extended keys are limited to deriving children with indexes between 0 and 4,294,967,295 (<code>0xffffffff</code>).
</p>
<h4>Code (Ruby)</h4>


<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span><span class="co"># -----</span></span>
<span><span class="co"># Utils - Needed for creating the fingerprint and checksum, and converting hex string to Base58</span></span>
<span><span class="co"># -----</span></span>
<span>require <span class="st">&#39;digest&#39;</span></span>
<span></span>
<span><span class="kw">def</span> create_fingerprint(parent_public_key)</span>
<span>    hash160 = <span class="dt">Digest</span>::<span class="dt">RMD160</span>.digest(<span class="dt">Digest</span>::<span class="dt">SHA256</span>.digest([parent_public_key].pack(<span class="st">&quot;H*&quot;</span>))) <span class="co"># hash160 it</span></span>
<span>    fingerprint = hash160[<span class="dv">0</span>...<span class="dv">4</span>].unpack(<span class="st">&quot;H*&quot;</span>).join <span class="co"># take first 4 bytes (and convert to hex)</span></span>
<span>    <span class="kw">return</span> fingerprint</span>
<span><span class="kw">end</span></span>
<span></span>
<span><span class="kw">def</span> hash256(hex)</span>
<span>    binary = [hex].pack(<span class="st">&quot;H*&quot;</span>)</span>
<span>    hash1 = <span class="dt">Digest</span>::<span class="dt">SHA256</span>.digest(binary)</span>
<span>    hash2 = <span class="dt">Digest</span>::<span class="dt">SHA256</span>.digest(hash1)</span>
<span>    result = hash2.unpack(<span class="st">&quot;H*&quot;</span>)[<span class="dv">0</span>]</span>
<span>    <span class="kw">return</span> result</span>
<span><span class="kw">end</span></span>
<span></span>
<span><span class="kw">def</span> checksum(hex)</span>
<span>    hash = hash256(hex) <span class="co"># Hash the data through SHA256 twice</span></span>
<span>    <span class="kw">return</span> hash[<span class="dv">0</span>...<span class="dv">8</span>]  <span class="co"># Return the first 4 bytes (8 characters)</span></span>
<span><span class="kw">end</span></span>
<span></span>
<span><span class="kw">def</span> base58_encode(hex)</span>
<span>    <span class="ot">@chars</span> =<span class="ot"> %w[</span></span>
<span><span class="st">      1 2 3 4 5 6 7 8 9</span></span>
<span><span class="st">    A B C D E F G H   J K L M N   P Q R S T U V W X Y Z</span></span>
<span><span class="st">    a b c d e f g h i j k   m n o p q r s t u v w x y z</span></span>
<span><span class="st">    </span><span class="ot">]</span></span>
<span>    <span class="ot">@base</span> = <span class="ot">@chars</span>.length</span>
<span></span>
<span>    i = hex.to_i(<span class="dv">16</span>)</span>
<span>    buffer = <span class="dt">String</span>.new</span>
<span></span>
<span>    <span class="kw">while</span> i &gt; <span class="dv">0</span></span>
<span>        remainder = i % <span class="ot">@base</span></span>
<span>        i = i / <span class="ot">@base</span></span>
<span>        buffer = <span class="ot">@chars</span>[remainder] + buffer</span>
<span>    <span class="kw">end</span></span>
<span></span>
<span>    <span class="co"># add &#39;1&#39;s to the start based on number of leading bytes of zeros</span></span>
<span>    leading_zero_bytes = (hex.match(<span class="ot">/^([0]+)/</span>) ? <span class="dt">$1</span> : <span class="st">&#39;&#39;</span>).size / <span class="dv">2</span></span>
<span></span>
<span>    (<span class="st">&quot;1&quot;</span>*leading_zero_bytes) + buffer</span>
<span><span class="kw">end</span></span>
<span></span>
<span><span class="co"># --------------------------</span></span>
<span><span class="co"># Extended Key Serialization</span></span>
<span><span class="co"># --------------------------</span></span>
<span>parent_public_key = <span class="st">&quot;0252c616d91a2488c1fd1f0f172e98f7d1f6e51f8f389b2f8d632a8b490d5f6da9&quot;</span> <span class="co"># needed to create fingerprint</span></span>
<span></span>
<span>chain_code  = <span class="st">&quot;05aae71d7c080474efaab01fa79e96f4c6cfe243237780b0df4bc36106228e31&quot;</span> <span class="co"># m/0</span></span>
<span>private_key = <span class="st">&quot;39f329fedba2a68e2a804fcd9aeea4104ace9080212a52ce8b52c1fb89850c72&quot;</span> <span class="co"># m/0</span></span>
<span></span>
<span><span class="co"># version + depth + fingerprint + childnumber + chain_code + key + (checksum)</span></span>
<span><span class="co">#</span></span>
<span><span class="co"># version:     puts xprv or xpub at the start</span></span>
<span><span class="co"># depth:       how many times this child has been derived from master key (0 = master key)</span></span>
<span><span class="co"># fingerprint: created from parent public key (allows you to spot adjacent xprv and xpubs)</span></span>
<span><span class="co"># childnumber: the index of this child key from the parent</span></span>
<span><span class="co"># chain_code:  the current chain code being used for this key</span></span>
<span><span class="co"># key:         the private or public key you want to create a serialized extended key for (prepend 0x00 for private)</span></span>
<span></span>
<span>version     = <span class="st">&quot;0488ade4&quot;</span> <span class="co"># private = 0x0488ade4 (xprv), public = 0x0488b21e (xpub)</span></span>
<span>depth       = <span class="st">&quot;01&quot;</span></span>
<span>fingerprint = create_fingerprint(parent_public_key) <span class="co">#=&gt; &quot;018c1259&quot;</span></span>
<span>childnumber = <span class="st">&quot;00000000&quot;</span></span>
<span>chain_code  = chain_code</span>
<span>key         = <span class="st">&quot;00&quot;</span> + private_key  <span class="co"># prepend 00 to private keys (to make them 33 bytes, the same as public keys)</span></span>
<span></span>
<span>serialized = version + depth + fingerprint + childnumber + chain_code + key</span>
<span>extended_private_key = base58_encode(serialized + checksum(serialized))</span>
<span></span>
<span>puts <span class="st">&quot;extended_private_key: </span><span class="ot">#{</span>extended_private_key<span class="ot">}</span><span class="st">&quot;</span> <span class="co">#=&gt; xprv9tuogRdb5YTgcL3P8Waj7REqDuQx4sXcodQaWTtEVFEp6yRKh1CjrWfXChnhgHeLDuXxo2auDZegMiVMGGxwxcrb2PmiGyCngLxvLeGsZRq</span></span></code></pre>

</div>
<h2>Code</h2>
<p>The following are complete code snippets for <em>creating</em>, <em>deriving</em>, and <em>serializing</em> <strong>extended keys</strong>.</p>
<h3>Ruby</h3>


<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span>require <span class="st">&#39;openssl&#39;</span> <span class="co"># HMAC</span></span>
<span>require <span class="st">&#39;ecdsa&#39;</span>   <span class="co"># private key to public key</span></span>
<span></span>
<span><span class="co"># ----</span></span>
<span><span class="co"># Seed</span></span>
<span><span class="co"># ----</span></span>
<span>seed = <span class="st">&quot;67f93560761e20617de26e0cb84f7234aaf373ed2e66295c3d7397e6d7ebe882ea396d5d293808b0defd7edd2babd4c091ad942e6a9351e6d075a29d4df872af&quot;</span></span>
<span>puts <span class="st">&quot;seed: </span><span class="ot">#{</span>seed<span class="ot">}</span><span class="st">&quot;</span></span>
<span>puts</span>
<span></span>
<span><span class="co"># --------------------</span></span>
<span><span class="co"># Generate Master Keys</span></span>
<span><span class="co"># --------------------</span></span>
<span><span class="co"># seed</span></span>
<span><span class="co"># |</span></span>
<span><span class="co"># m</span></span>
<span></span>
<span><span class="co"># HMAC</span></span>
<span>hmac = <span class="dt">OpenSSL</span>::<span class="dt">HMAC</span>.hexdigest(<span class="dt">OpenSSL</span>::<span class="dt">Digest</span>::<span class="dt">SHA512</span>.new, <span class="st">&quot;Bitcoin seed&quot;</span>, [seed].pack(<span class="st">&quot;H*&quot;</span>)) <span class="co"># digest, key, data</span></span>
<span>master_private_key = hmac[<span class="dv">0</span>..<span class="dv">63</span>] <span class="co"># left side of digest</span></span>
<span>master_chain_code = hmac[<span class="dv">64</span>..-<span class="dv">1</span>] <span class="co"># right side of digest</span></span>
<span></span>
<span><span class="co"># &gt; The SHA512-HMAC function is reused because it is already part of the standard elsewhere, but it takes a key in addition to the data being hashed.</span></span>
<span><span class="co"># As the key can be arbitrary, we opted to use to make sure the key derivation was Bitcoin-specific. -- Pieter Wuille</span></span>
<span></span>
<span><span class="co"># Get Public Key (multiply generator point by private key)</span></span>
<span>master_public_key = <span class="dt">ECDSA</span>::<span class="dt">Group</span>::<span class="dt">Secp256k1</span>.generator.multiply_by_scalar(master_private_key.to_i(<span class="dv">16</span>)) <span class="co"># multiply generator point by private key</span></span>
<span>master_public_key = <span class="dt">ECDSA</span>::<span class="dt">Format</span>::<span class="dt">PointOctetString</span>.encode(master_public_key, <span class="st">compression: </span><span class="dv">true</span>).unpack(<span class="st">&quot;H*&quot;</span>)[<span class="dv">0</span>] <span class="co"># encode to compressed public key format</span></span>
<span></span>
<span>puts <span class="st">&quot;master_chain_code:  </span><span class="ot">#{</span>master_chain_code<span class="ot">}</span><span class="st">&quot;</span>  <span class="co">#=&gt; 463223aac10fb13f291a1bc76bc26003d98da661cb76df61e750c139826dea8b</span></span>
<span>puts <span class="st">&quot;master_private_key: </span><span class="ot">#{</span>master_private_key<span class="ot">}</span><span class="st">&quot;</span> <span class="co">#=&gt; f79bb0d317b310b261a55a8ab393b4c8a1aba6fa4d08aef379caba502d5d67f9</span></span>
<span>puts <span class="st">&quot;master_public_key:  </span><span class="ot">#{</span>master_public_key<span class="ot">}</span><span class="st">&quot;</span>  <span class="co">#=&gt; 0252c616d91a2488c1fd1f0f172e98f7d1f6e51f8f389b2f8d632a8b490d5f6da9</span></span>
<span>puts</span>
<span></span>
<span><span class="co"># --------------------------</span></span>
<span><span class="co"># Child Extended Private Key</span></span>
<span><span class="co"># --------------------------</span></span>
<span><span class="co"># m</span></span>
<span><span class="co"># |- m/0</span></span>
<span><span class="co"># |- m/1</span></span>
<span><span class="co"># |- m/2</span></span>
<span><span class="co"># .</span></span>
<span><span class="co"># .</span></span>
<span><span class="co"># .</span></span>
<span><span class="co"># |- m/2147483648 (hardened - m/0&#39;)</span></span>
<span>parent_private_key = master_private_key</span>
<span>parent_chain_code  = master_chain_code</span>
<span>i = <span class="dv">0</span> <span class="co"># child number</span></span>
<span></span>
<span><span class="co"># Normal (parent public key can create child public key for this private key)</span></span>
<span><span class="kw">if</span> i &lt; <span class="dv">2</span>**<span class="dv">31</span></span>
<span>    point = <span class="dt">ECDSA</span>::<span class="dt">Group</span>::<span class="dt">Secp256k1</span>.generator.multiply_by_scalar(parent_private_key.to_i(<span class="dv">16</span>)) <span class="co"># multiply generator point by private key</span></span>
<span>    point = <span class="dt">ECDSA</span>::<span class="dt">Format</span>::<span class="dt">PointOctetString</span>.encode(point, <span class="st">compression: </span><span class="dv">true</span>).unpack(<span class="st">&quot;H*&quot;</span>)[<span class="dv">0</span>] <span class="co"># encode to compressed public key format</span></span>
<span>    data = [point].pack(<span class="st">&quot;H*&quot;</span>) + [i].pack(<span class="st">&quot;N&quot;</span>)     <span class="co"># point(private_key) i</span></span>
<span><span class="kw">end</span></span>
<span></span>
<span><span class="co"># &gt; This means that it is possible to give someone a parent extended key (public key + chain code), and they can derive all public keys in the chain. -- Pieter Wuille</span></span>
<span></span>
<span><span class="co"># Hardened (parent public key cannot create public key for this private key)</span></span>
<span><span class="kw">if</span> i &gt;= <span class="dv">2</span>**<span class="dv">31</span></span>
<span>  data = [<span class="st">&quot;00&quot;</span>].pack(<span class="st">&quot;H*&quot;</span>) + [parent_private_key].pack(<span class="st">&quot;H*&quot;</span>) + [i].pack(<span class="st">&quot;N&quot;</span>)  <span class="co"># 0x00 private_key i</span></span>
<span><span class="kw">end</span></span>
<span></span>
<span><span class="co"># &gt; Hardened derivation should be the default unless there is a good reason why you need to be able to generate public keys without access to the private key. -- Pieter Wuille</span></span>
<span><span class="co"># &gt; You cannot derive hardened public keys from xpubs, because hardening is specifically designed to make exactly that impossible. -- Pieter Wuille</span></span>
<span></span>
<span><span class="co"># Put data and key through hmac</span></span>
<span>key = [parent_chain_code].pack(<span class="st">&quot;H*&quot;</span>) <span class="co"># chain code is key for hmac</span></span>
<span>hmac = <span class="dt">OpenSSL</span>::<span class="dt">HMAC</span>.hexdigest(<span class="dt">OpenSSL</span>::<span class="dt">Digest</span>::<span class="dt">SHA512</span>.new, key, data) <span class="co"># digest, key, data</span></span>
<span>il = hmac[<span class="dv">0</span>..<span class="dv">63</span>]  <span class="co"># left side of intermediate key [32 bytes]</span></span>
<span>ir = hmac[<span class="dv">64</span>..-<span class="dv">1</span>] <span class="co"># right side of intermediate key [32 bytes]</span></span>
<span></span>
<span><span class="co"># Chain code is last 32 bytes</span></span>
<span>child_chain_code = ir</span>
<span></span>
<span><span class="kw">if</span> child_chain_code.to_i(<span class="dv">16</span>) &gt;= <span class="dt">ECDSA</span>::<span class="dt">Group</span>::<span class="dt">Secp256k1</span>.order</span>
<span>    raise <span class="st">&quot;Chain code is greater than the order of the curve. Try the next index.&quot;</span></span>
<span><span class="kw">end</span></span>
<span></span>
<span><span class="co"># Work out the corresponding public key too (optional)</span></span>
<span>child_private_key = (il.to_i(<span class="dv">16</span>) + parent_private_key.to_i(<span class="dv">16</span>)) % <span class="dt">ECDSA</span>::<span class="dt">Group</span>::<span class="dt">Secp256k1</span>.order <span class="co"># (il + parent_key) % n</span></span>
<span>child_private_key = child_private_key.to_s(<span class="dv">16</span>).rjust(<span class="dv">64</span>, <span class="ch">&#39;0&#39;</span>) <span class="co"># convert to hex (and make sure it&#39;s 32 bytes long)</span></span>
<span></span>
<span><span class="kw">if</span> child_private_key.to_i(<span class="dv">16</span>) == <span class="dv">0</span></span>
<span>    raise <span class="st">&quot;Child private key is zero. Try the next index.&quot;</span></span>
<span><span class="kw">end</span></span>
<span></span>
<span>child_public_key = <span class="dt">ECDSA</span>::<span class="dt">Group</span>::<span class="dt">Secp256k1</span>.generator.multiply_by_scalar(child_private_key.to_i(<span class="dv">16</span>)) <span class="co"># work out the public key for this too</span></span>
<span>child_public_key = <span class="dt">ECDSA</span>::<span class="dt">Format</span>::<span class="dt">PointOctetString</span>.encode(child_public_key, <span class="st">compression: </span><span class="dv">true</span>).unpack(<span class="st">&quot;H*&quot;</span>)[<span class="dv">0</span>] <span class="co"># encode to compressed public key format</span></span>
<span></span>
<span>puts <span class="st">&quot;child_chain_code:   </span><span class="ot">#{</span>child_chain_code<span class="ot">}</span><span class="st">&quot;</span></span>
<span>puts <span class="st">&quot;child_private_key:  </span><span class="ot">#{</span>child_private_key<span class="ot">}</span><span class="st">&quot;</span></span>
<span>puts <span class="st">&quot;child_public_key:   </span><span class="ot">#{</span>child_public_key<span class="ot">}</span><span class="st">&quot;</span></span>
<span>puts</span>
<span></span>
<span><span class="co"># -------------------------</span></span>
<span><span class="co"># Child Extended Public Key</span></span>
<span><span class="co"># -------------------------</span></span>
<span><span class="co"># m -------- p</span></span>
<span><span class="co">#            |- p/0</span></span>
<span><span class="co">#            |- p/1</span></span>
<span><span class="co">#            |- p/3</span></span>
<span>parent_public_key = master_public_key</span>
<span>parent_chain_code = master_chain_code</span>
<span>i = <span class="dv">0</span> <span class="co"># child number</span></span>
<span></span>
<span><span class="kw">if</span> i &gt;= <span class="dv">2</span>**<span class="dv">31</span></span>
<span>    raise <span class="st">&quot;Can&#39;t create hardened child public keys from parent public keys.&quot;</span></span>
<span><span class="kw">end</span></span>
<span></span>
<span>key = [parent_chain_code].pack(<span class="st">&quot;H*&quot;</span>)</span>
<span>data = [parent_public_key].pack(<span class="st">&quot;H*&quot;</span>) + [i].pack(<span class="st">&quot;N&quot;</span>) <span class="co"># 32-bit unsigned, network (big-endian) byte order</span></span>
<span></span>
<span><span class="co"># Put data and key through hmac</span></span>
<span>hmac = <span class="dt">OpenSSL</span>::<span class="dt">HMAC</span>.hexdigest(<span class="dt">OpenSSL</span>::<span class="dt">Digest</span>::<span class="dt">SHA512</span>.new, key, data)</span>
<span>il = hmac[<span class="dv">0</span>..<span class="dv">63</span>]  <span class="co"># left side of intermediate key [32 bytes]</span></span>
<span>ir = hmac[<span class="dv">64</span>..-<span class="dv">1</span>] <span class="co"># right side of intermediate key [32 bytes]</span></span>
<span></span>
<span><span class="co"># Chain code is last 32 bytes</span></span>
<span>child_chain_code = hmac[<span class="dv">64</span>..-<span class="dv">1</span>]</span>
<span></span>
<span><span class="kw">if</span> il.to_i(<span class="dv">16</span>) &gt;= <span class="dt">ECDSA</span>::<span class="dt">Group</span>::<span class="dt">Secp256k1</span>.order</span>
<span>    raise <span class="st">&quot;Result of digest is greater than the order of the curve. Try the next index.&quot;</span></span>
<span><span class="kw">end</span></span>
<span></span>
<span><span class="co"># Work out the child public key</span></span>
<span>point_hmac   = <span class="dt">ECDSA</span>::<span class="dt">Group</span>::<span class="dt">Secp256k1</span>.generator.multiply_by_scalar(il.to_i(<span class="dv">16</span>))                               <span class="co"># convert hmac il to a point</span></span>
<span>point_public = <span class="dt">ECDSA</span>::<span class="dt">Format</span>::<span class="dt">PointOctetString</span>.decode([parent_public_key].pack(<span class="st">&quot;H*&quot;</span>), <span class="dt">ECDSA</span>::<span class="dt">Group</span>::<span class="dt">Secp256k1</span>) <span class="co"># convert parent_public_key to a point</span></span>
<span>point = point_hmac.add_to_point(point_public)                                                                  <span class="co"># point addition</span></span>
<span></span>
<span><span class="kw">if</span> (point == <span class="dt">ECDSA</span>::<span class="dt">Group</span>::<span class="dt">Secp256k1</span>.infinity)</span>
<span>    raise <span class="st">&quot;Child public key point is at point of infinitiy. Try the next index.&quot;</span></span>
<span><span class="kw">end</span></span>
<span></span>
<span>child_public_key = <span class="dt">ECDSA</span>::<span class="dt">Format</span>::<span class="dt">PointOctetString</span>.encode(point, <span class="st">compression: </span><span class="dv">true</span>).unpack(<span class="st">&quot;H*&quot;</span>)[<span class="dv">0</span>] <span class="co"># encode to compress public key</span></span>
<span></span>
<span>puts <span class="st">&quot;child_chain_code:   </span><span class="ot">#{</span>child_chain_code<span class="ot">}</span><span class="st">&quot;</span></span>
<span>puts <span class="st">&quot;child_public_key:   </span><span class="ot">#{</span>child_public_key<span class="ot">}</span><span class="st">&quot;</span></span>
<span>puts</span>
<span></span>
<span><span class="co"># --------------------------</span></span>
<span><span class="co"># Extended Key Serialization</span></span>
<span><span class="co"># --------------------------</span></span>
<span></span>
<span><span class="co"># Utils - Needed for creating the fingerprint and checksum, and converting hex string to Base58</span></span>
<span><span class="co"># -----</span></span>
<span>require <span class="st">&#39;digest&#39;</span></span>
<span></span>
<span><span class="kw">def</span> create_fingerprint(parent_public_key)</span>
<span>    hash160 = <span class="dt">Digest</span>::<span class="dt">RMD160</span>.digest(<span class="dt">Digest</span>::<span class="dt">SHA256</span>.digest([parent_public_key].pack(<span class="st">&quot;H*&quot;</span>))) <span class="co"># hash160 it</span></span>
<span>    fingerprint = hash160[<span class="dv">0</span>...<span class="dv">4</span>].unpack(<span class="st">&quot;H*&quot;</span>).join <span class="co"># take first 4 bytes (and convert to hex)</span></span>
<span>    <span class="kw">return</span> fingerprint</span>
<span><span class="kw">end</span></span>
<span></span>
<span><span class="kw">def</span> hash256(hex)</span>
<span>    binary = [hex].pack(<span class="st">&quot;H*&quot;</span>)</span>
<span>    hash1 = <span class="dt">Digest</span>::<span class="dt">SHA256</span>.digest(binary)</span>
<span>    hash2 = <span class="dt">Digest</span>::<span class="dt">SHA256</span>.digest(hash1)</span>
<span>    result = hash2.unpack(<span class="st">&quot;H*&quot;</span>)[<span class="dv">0</span>]</span>
<span>    <span class="kw">return</span> result</span>
<span><span class="kw">end</span></span>
<span></span>
<span><span class="kw">def</span> checksum(hex)</span>
<span>    hash = hash256(hex) <span class="co"># Hash the data through SHA256 twice</span></span>
<span>    <span class="kw">return</span> hash[<span class="dv">0</span>...<span class="dv">8</span>]  <span class="co"># Return the first 4 bytes (8 characters)</span></span>
<span><span class="kw">end</span></span>
<span></span>
<span><span class="kw">def</span> base58_encode(hex)</span>
<span>    <span class="ot">@chars</span> =<span class="ot"> %w[</span></span>
<span><span class="st">      1 2 3 4 5 6 7 8 9</span></span>
<span><span class="st">    A B C D E F G H   J K L M N   P Q R S T U V W X Y Z</span></span>
<span><span class="st">    a b c d e f g h i j k   m n o p q r s t u v w x y z</span></span>
<span><span class="st">    </span><span class="ot">]</span></span>
<span>    <span class="ot">@base</span> = <span class="ot">@chars</span>.length</span>
<span></span>
<span>    i = hex.to_i(<span class="dv">16</span>)</span>
<span>    buffer = <span class="dt">String</span>.new</span>
<span></span>
<span>    <span class="kw">while</span> i &gt; <span class="dv">0</span></span>
<span>        remainder = i % <span class="ot">@base</span></span>
<span>        i = i / <span class="ot">@base</span></span>
<span>        buffer = <span class="ot">@chars</span>[remainder] + buffer</span>
<span>    <span class="kw">end</span></span>
<span></span>
<span>    <span class="co"># add &#39;1&#39;s to the start based on number of leading bytes of zeros</span></span>
<span>    leading_zero_bytes = (hex.match(<span class="ot">/^([0]+)/</span>) ? <span class="dt">$1</span> : <span class="st">&#39;&#39;</span>).size / <span class="dv">2</span></span>
<span></span>
<span>    (<span class="st">&quot;1&quot;</span>*leading_zero_bytes) + buffer</span>
<span><span class="kw">end</span></span>
<span></span>
<span><span class="co"># ---------</span></span>
<span><span class="co"># Serialize</span></span>
<span><span class="co"># ---------</span></span>
<span>parent_public_key = master_public_key <span class="co"># needed to create fingerprint</span></span>
<span></span>
<span>chain_code  = child_chain_code <span class="co"># m/0</span></span>
<span>private_key = child_private_key <span class="co"># m/0</span></span>
<span></span>
<span><span class="co"># version + depth + fingerprint + childnumber + chain_code + key + (checksum)</span></span>
<span><span class="co">#</span></span>
<span><span class="co"># version:     puts xprv or xpub at the start</span></span>
<span><span class="co"># depth:       how many times this child has been derived from master key (0 = master key)</span></span>
<span><span class="co"># fingerprint: created from parent public key (allows you to spot adjacent xprv and xpubs)</span></span>
<span><span class="co"># childnumber: the index of this child key from the parent</span></span>
<span><span class="co"># chain_code:  the current chain code being used for this key</span></span>
<span><span class="co"># key:         the private or public key you want to create a serialized extended key for (prepend 0x00 for private)</span></span>
<span></span>
<span>version     = <span class="st">&quot;0488ade4&quot;</span> <span class="co"># private = 0x0488ade4 (xprv), public = 0x0488b21e (xpub)</span></span>
<span>depth       = <span class="st">&quot;01&quot;</span></span>
<span>fingerprint = create_fingerprint(parent_public_key) <span class="co">#=&gt; &quot;018c1259&quot;</span></span>
<span>childnumber = <span class="st">&quot;00000000&quot;</span> <span class="co"># 4 byte hexadecimal string</span></span>
<span>chain_code  = chain_code</span>
<span>key         = <span class="st">&quot;00&quot;</span> + private_key  <span class="co"># prepend 00 to private keys (to make them 33 bytes, the same as public keys)</span></span>
<span></span>
<span>serialized = version + depth + fingerprint + childnumber + chain_code + key</span>
<span>extended_private_key = base58_encode(serialized + checksum(serialized))</span>
<span></span>
<span>puts <span class="st">&quot;extended_private_key: </span><span class="ot">#{</span>extended_private_key<span class="ot">}</span><span class="st">&quot;</span></span></code></pre>

</div>
<h3>PHP</h3>


<div class="sourceCode"><pre class="sourceCode php"><code class="sourceCode php"><span><span class="kw">&lt;?php</span></span>
<span><span class="co">// Note: Requires https://github.com/Bit-Wasp/secp256k1-php</span></span>
<span></span>
<span><span class="co">// ------------------</span></span>
<span><span class="co">// Seed to Master Key</span></span>
<span><span class="co">// ------------------</span></span>
<span></span>
<span><span class="kw">$seed</span> = <span class="st">&quot;67f93560761e20617de26e0cb84f7234aaf373ed2e66295c3d7397e6d7ebe882ea396d5d293808b0defd7edd2babd4c091ad942e6a9351e6d075a29d4df872af&quot;</span><span class="ot">;</span></span>
<span><span class="kw">echo</span> <span class="st">&quot;seed: </span><span class="kw">$seed</span><span class="st">&quot;</span>.<span class="kw">PHP_EOL</span><span class="ot">;</span></span>
<span><span class="kw">echo</span> <span class="kw">PHP_EOL</span><span class="ot">;</span></span>
<span></span>
<span><span class="co">// Hash it through HMAC-SHA512 and split in to two halves</span></span>
<span><span class="co">// </span></span>
<span><span class="co">//             seed</span></span>
<span><span class="co">//              |</span></span>
<span><span class="co">//            |----|</span></span>
<span><span class="co">//            |HMAC|</span></span>
<span><span class="co">//            |----|</span></span>
<span><span class="co">//              |</span></span>
<span><span class="co">// |    priv    | chain code |</span></span>
<span><span class="co">// </span></span>
<span><span class="kw">$hmac</span> = <span class="fu">hash_hmac</span><span class="ot">(</span><span class="st">&quot;sha512&quot;</span><span class="ot">,</span> <span class="fu">hex2bin</span><span class="ot">(</span><span class="kw">$seed</span><span class="ot">),</span> <span class="st">&quot;Bitcoin seed&quot;</span><span class="ot">);</span> <span class="co">// algo, data, key, raw_output (optional)</span></span>
<span><span class="kw">$master_private_key</span> = <span class="fu">substr</span><span class="ot">(</span><span class="kw">$hmac</span><span class="ot">,</span> <span class="dv">0</span><span class="ot">,</span> <span class="dv">64</span><span class="ot">);</span> <span class="co">// first half is private key</span></span>
<span><span class="kw">$master_chain_code</span> = <span class="fu">substr</span><span class="ot">(</span><span class="kw">$hmac</span><span class="ot">,</span> <span class="dv">64</span><span class="ot">);</span>     <span class="co">// second half is chain code</span></span>
<span><span class="co">//</span></span>
<span><span class="co">// m (priv, chain_code)</span></span>
<span><span class="co">// </span></span>
<span><span class="kw">echo</span> <span class="st">&quot;master_chain_code:  </span><span class="kw">$master_chain_code</span><span class="st">&quot;</span>.<span class="kw">PHP_EOL</span><span class="ot">;</span></span>
<span><span class="kw">echo</span> <span class="st">&quot;master_private_key: </span><span class="kw">$master_private_key</span><span class="st">&quot;</span>.<span class="kw">PHP_EOL</span><span class="ot">;</span></span>
<span></span>
<span><span class="co">// Use elliptic curve mathematics to go from private key to the public key</span></span>
<span><span class="co">// </span></span>
<span><span class="co">// priv -&gt; pub</span></span>
<span><span class="co">// </span></span>
<span><span class="kw">$context</span> = secp256k1_context_create<span class="ot">(</span><span class="kw">SECP256K1_CONTEXT_SIGN</span> | <span class="kw">SECP256K1_CONTEXT_VERIFY</span><span class="ot">);</span> <span class="co">// set curve context</span></span>
<span><span class="kw">$point</span> = <span class="kw">null</span><span class="ot">;</span> secp256k1_ec_pubkey_create<span class="ot">(</span><span class="kw">$context</span><span class="ot">,</span> <span class="kw">$point</span><span class="ot">,</span> <span class="fu">hex2bin</span><span class="ot">(</span><span class="kw">$master_private_key</span><span class="ot">));</span> <span class="co">// get public key point</span></span>
<span><span class="kw">$serialized</span> = <span class="st">&#39;&#39;</span><span class="ot">;</span> secp256k1_ec_pubkey_serialize<span class="ot">(</span><span class="kw">$context</span><span class="ot">,</span> <span class="kw">$serialized</span><span class="ot">,</span> <span class="kw">$point</span><span class="ot">,</span> <span class="kw">SECP256K1_EC_COMPRESSED</span><span class="ot">);</span> <span class="co">// serialize to compressed public key</span></span>
<span><span class="kw">$master_public_key</span> = <span class="fu">bin2hex</span><span class="ot">(</span><span class="kw">$serialized</span><span class="ot">);</span></span>
<span></span>
<span><span class="co">// </span></span>
<span><span class="co">// m (priv, pub, chain_code)</span></span>
<span><span class="co">// </span></span>
<span><span class="kw">echo</span> <span class="st">&quot;master_public_key:  </span><span class="kw">$master_public_key</span><span class="st">&quot;</span>.<span class="kw">PHP_EOL</span><span class="ot">;</span></span>
<span><span class="kw">echo</span> <span class="kw">PHP_EOL</span><span class="ot">;</span></span>
<span></span>
<span><span class="co">// ---------------------------------------------------------</span></span>
<span><span class="co">// Parent Extended Private Key to Child Extended Private Key (m/0)</span></span>
<span><span class="co">// ---------------------------------------------------------</span></span>
<span><span class="co">// m (priv, pub, chain code)</span></span>
<span><span class="co">// |</span></span>
<span><span class="co">// m/0 (priv, pub, chain code)</span></span>
<span><span class="kw">$parent_private_key</span> = <span class="kw">$master_private_key</span><span class="ot">;</span> <span class="co">// get private key of parent</span></span>
<span><span class="kw">$parent_chain_code</span>  = <span class="kw">$master_chain_code</span><span class="ot">;</span>   <span class="co">// get chain code of parent</span></span>
<span><span class="kw">$i</span> = <span class="dv">0</span><span class="ot">;</span>                                    <span class="co">// the index of this child from parent</span></span>
<span></span>
<span><span class="co">// Normal Child (extended public key can derive its public keys)</span></span>
<span><span class="kw">if</span> <span class="ot">(</span><span class="kw">$i</span> &lt; <span class="dv">2</span>**<span class="dv">31</span><span class="ot">)</span> { <span class="co">// first half of possible indexes are normal children</span></span>
<span>    <span class="co">// Get public key point for the parent private key</span></span>
<span>    <span class="kw">$parent_public_key</span> = <span class="kw">$master_public_key</span><span class="ot">;</span> <span class="co">// you can derive this from the parent private key using the elliptic curve mathematics above</span></span>
<span>    <span class="co">// The `data` for the upcoming HMAC is the parent public key + index</span></span>
<span>    <span class="co">//  data = | parent public key (33 bytes) | i (4 bytes) |</span></span>
<span>    <span class="kw">$data</span> = <span class="fu">pack</span><span class="ot">(</span><span class="st">&quot;H*&quot;</span><span class="ot">,</span> <span class="kw">$parent_public_key</span><span class="ot">)</span>.<span class="fu">pack</span><span class="ot">(</span><span class="st">&quot;N&quot;</span><span class="ot">,</span> <span class="kw">$i</span><span class="ot">);</span></span>
<span>}</span>
<span></span>
<span><span class="co">// Hardened Child (extended public key cannot derive its public keys)</span></span>
<span><span class="kw">if</span> <span class="ot">(</span><span class="kw">$i</span> &gt;= <span class="dv">2</span>**<span class="dv">31</span> <span class="ot">)</span> { <span class="co">// second half of possible indexes are hardened children</span></span>
<span>    <span class="co">//  data = | 00 | parent private key (32 bytes) | i (4 bytes) |</span></span>
<span>    <span class="kw">$data</span> = <span class="fu">pack</span><span class="ot">(</span><span class="st">&quot;H*&quot;</span><span class="ot">,</span> <span class="st">&quot;00&quot;</span><span class="ot">)</span>.<span class="fu">pack</span><span class="ot">(</span><span class="st">&quot;H*&quot;</span><span class="ot">,</span> <span class="kw">$master_private_key</span><span class="ot">)</span>.<span class="fu">pack</span><span class="ot">(</span><span class="st">&quot;N&quot;</span><span class="ot">,</span> <span class="kw">$i</span><span class="ot">);</span></span>
<span>}</span>
<span></span>
<span><span class="co">// Put data (public key or private key) and chain code through HMAC-SHA512</span></span>
<span><span class="kw">$hmac</span> = <span class="fu">hash_hmac</span><span class="ot">(</span><span class="st">&quot;sha512&quot;</span><span class="ot">,</span> <span class="kw">$data</span><span class="ot">,</span> <span class="fu">hex2bin</span><span class="ot">(</span><span class="kw">$parent_chain_code</span><span class="ot">));</span> <span class="co">// algo, data, key</span></span>
<span><span class="kw">$left</span> = <span class="fu">substr</span><span class="ot">(</span><span class="kw">$hmac</span><span class="ot">,</span> <span class="dv">0</span><span class="ot">,</span> <span class="dv">64</span><span class="ot">);</span></span>
<span><span class="kw">$right</span> = <span class="fu">substr</span><span class="ot">(</span><span class="kw">$hmac</span><span class="ot">,</span> <span class="dv">64</span><span class="ot">);</span></span>
<span></span>
<span><span class="co">// Child chain code is right side of HMAC-SHA512 </span></span>
<span><span class="co">// m</span></span>
<span><span class="co">// |</span></span>
<span><span class="co">// m/0 (chain code)</span></span>
<span><span class="kw">$child_chain_code</span> = <span class="kw">$right</span><span class="ot">;</span></span>
<span><span class="kw">echo</span> <span class="st">&quot;child_chain_code:   </span><span class="kw">$child_chain_code</span><span class="st">&quot;</span>.<span class="kw">PHP_EOL</span><span class="ot">;</span></span>
<span></span>
<span><span class="co">// Check child chain code is valid (not greater than the number of points on the curve)</span></span>
<span><span class="kw">if</span> <span class="ot">(</span><span class="fu">hexdec</span><span class="ot">(</span><span class="kw">$child_chain_code</span><span class="ot">)</span> &gt;= <span class="dv">115792089237316195423570985008687907852837564279074904382605163141518161494337</span><span class="ot">)</span> {</span>
<span>    <span class="kw">throw</span> <span class="kw">new</span> <span class="kw">Exception</span><span class="ot">(</span><span class="st">&quot;Child chain code is greater than or equal to the order of the elliptic curve. Try next index.&quot;</span><span class="ot">);</span></span>
<span>}</span>
<span></span>
<span><span class="co">// Calculate child private key (left side of hmac + parent private key) % order</span></span>
<span><span class="kw">function</span> bchexdec<span class="ot">(</span><span class="kw">$hex</span><span class="ot">)</span> { <span class="co">// need a utility function to work with addition of large hexadecimal numbers</span></span>
<span>    <span class="kw">if</span><span class="ot">(</span><span class="fu">strlen</span><span class="ot">(</span><span class="kw">$hex</span><span class="ot">)</span> == <span class="dv">1</span><span class="ot">)</span> {</span>
<span>        <span class="kw">return</span> <span class="fu">hexdec</span><span class="ot">(</span><span class="kw">$hex</span><span class="ot">);</span></span>
<span>    } <span class="kw">else</span> {</span>
<span>        <span class="kw">$remain</span> = <span class="fu">substr</span><span class="ot">(</span><span class="kw">$hex</span><span class="ot">,</span> <span class="dv">0</span><span class="ot">,</span> <span class="dv">-1</span><span class="ot">);</span></span>
<span>        <span class="kw">$last</span> = <span class="fu">substr</span><span class="ot">(</span><span class="kw">$hex</span><span class="ot">,</span> <span class="dv">-1</span><span class="ot">);</span></span>
<span>        <span class="kw">return</span> <span class="fu">bcadd</span><span class="ot">(</span><span class="fu">bcmul</span><span class="ot">(</span><span class="dv">16</span><span class="ot">,</span> bchexdec<span class="ot">(</span><span class="kw">$remain</span><span class="ot">)),</span> <span class="fu">hexdec</span><span class="ot">(</span><span class="kw">$last</span><span class="ot">));</span></span>
<span>    }</span>
<span>}</span>
<span></span>
<span><span class="kw">function</span> bcdechex<span class="ot">(</span><span class="kw">$dec</span><span class="ot">)</span> { <span class="co">// need a utility function to convert large integer back to hexadecimal</span></span>
<span>    <span class="kw">$last</span> = <span class="fu">bcmod</span><span class="ot">(</span><span class="kw">$dec</span><span class="ot">,</span> <span class="dv">16</span><span class="ot">);</span></span>
<span>    <span class="kw">$remain</span> = <span class="fu">bcdiv</span><span class="ot">(</span><span class="fu">bcsub</span><span class="ot">(</span><span class="kw">$dec</span><span class="ot">,</span> <span class="kw">$last</span><span class="ot">),</span> <span class="dv">16</span><span class="ot">);</span></span>
<span></span>
<span>    <span class="kw">if</span><span class="ot">(</span><span class="kw">$remain</span> == <span class="dv">0</span><span class="ot">)</span> {</span>
<span>        <span class="kw">return</span> <span class="fu">dechex</span><span class="ot">(</span><span class="kw">$last</span><span class="ot">);</span></span>
<span>    } <span class="kw">else</span> {</span>
<span>        <span class="kw">return</span> bcdechex<span class="ot">(</span><span class="kw">$remain</span><span class="ot">)</span>.<span class="fu">dechex</span><span class="ot">(</span><span class="kw">$last</span><span class="ot">);</span></span>
<span>    }</span>
<span>}</span>
<span></span>
<span><span class="co">// child private key = (left + parent private key) % order</span></span>
<span><span class="co">// m</span></span>
<span><span class="co">// |</span></span>
<span><span class="co">// m/0 (priv)</span></span>
<span><span class="kw">$add</span> = <span class="fu">bcadd</span><span class="ot">(</span>bchexdec<span class="ot">(</span><span class="kw">$left</span><span class="ot">),</span> bchexdec<span class="ot">(</span><span class="kw">$parent_private_key</span><span class="ot">));</span> <span class="co">// add left side of hmac to parent private key</span></span>
<span><span class="kw">$mod</span> = <span class="fu">bcmod</span><span class="ot">(</span><span class="kw">$add</span><span class="ot">,</span> <span class="st">&quot;115792089237316195423570985008687907852837564279074904382605163141518161494337&quot;</span><span class="ot">);</span> <span class="co">// modulus the order of the curve</span></span>
<span><span class="kw">$child_private_key</span> = <span class="fu">str_pad</span><span class="ot">(</span>bcdechex<span class="ot">(</span><span class="kw">$mod</span><span class="ot">),</span> <span class="dv">64</span><span class="ot">,</span> <span class="st">&quot;0&quot;</span><span class="ot">,</span> <span class="kw">STR_PAD_LEFT</span><span class="ot">);</span> <span class="co">// ensure it is 64 chars (prepend zeros)</span></span>
<span></span>
<span><span class="co">// Check child private key is valid (not zero)</span></span>
<span><span class="kw">if</span> <span class="ot">(</span><span class="fu">hexdec</span><span class="ot">(</span><span class="kw">$child_private_key</span> === <span class="dv">0</span><span class="ot">))</span> {</span>
<span>    <span class="kw">throw</span> <span class="kw">new</span> <span class="kw">Exception</span><span class="ot">(</span><span class="st">&quot;Child private key is zero (so it&#39;s invalid). Try next index.&quot;</span><span class="ot">);</span></span>
<span>}</span>
<span><span class="kw">echo</span> <span class="st">&quot;child_private_key:  </span><span class="kw">$child_private_key</span><span class="st">&quot;</span>.<span class="kw">PHP_EOL</span><span class="ot">;</span></span>
<span></span>
<span><span class="co">// calculate corresponding child public key from this child private key</span></span>
<span><span class="co">// m</span></span>
<span><span class="co">// |</span></span>
<span><span class="co">// m/0 (pub)</span></span>
<span><span class="kw">$context</span> = secp256k1_context_create<span class="ot">(</span><span class="kw">SECP256K1_CONTEXT_SIGN</span> | <span class="kw">SECP256K1_CONTEXT_VERIFY</span><span class="ot">);</span> <span class="co">// set curve context</span></span>
<span><span class="kw">$point</span> = <span class="kw">null</span><span class="ot">;</span> secp256k1_ec_pubkey_create<span class="ot">(</span><span class="kw">$context</span><span class="ot">,</span> <span class="kw">$point</span><span class="ot">,</span> <span class="fu">hex2bin</span><span class="ot">(</span><span class="kw">$child_private_key</span><span class="ot">));</span> <span class="co">// get public key point</span></span>
<span><span class="kw">$serialized</span> = <span class="st">&#39;&#39;</span><span class="ot">;</span> secp256k1_ec_pubkey_serialize<span class="ot">(</span><span class="kw">$context</span><span class="ot">,</span> <span class="kw">$serialized</span><span class="ot">,</span> <span class="kw">$point</span><span class="ot">,</span> <span class="kw">SECP256K1_EC_COMPRESSED</span><span class="ot">);</span> <span class="co">// serialize to compressed public key</span></span>
<span><span class="kw">$child_public_key</span> = <span class="fu">bin2hex</span><span class="ot">(</span><span class="kw">$serialized</span><span class="ot">);</span></span>
<span><span class="kw">echo</span> <span class="st">&quot;child_public_key:   </span><span class="kw">$child_public_key</span><span class="st">&quot;</span>.<span class="kw">PHP_EOL</span><span class="ot">;</span> <span class="co">// note may need to pad hex</span></span>
<span><span class="kw">echo</span> <span class="kw">PHP_EOL</span><span class="ot">;</span></span>
<span></span>
<span><span class="co">// -------------------------------------------------------</span></span>
<span><span class="co">// Parent Extended Public Key to Child Extended Public Key (m/0)</span></span>
<span><span class="co">// -------------------------------------------------------</span></span>
<span><span class="co">// m -------- p (pub, chain code)</span></span>
<span><span class="co">//            |</span></span>
<span><span class="co">//            p/0 (pub, chain code)</span></span>
<span><span class="kw">$parent_public_key</span> = <span class="kw">$master_public_key</span><span class="ot">;</span> <span class="co">// get public key of parent</span></span>
<span><span class="kw">$parent_chain_code</span> = <span class="kw">$master_chain_code</span><span class="ot">;</span> <span class="co">// get chain code of parent</span></span>
<span><span class="kw">$i</span> = <span class="dv">0</span><span class="ot">;</span>                                  <span class="co">// the index of this child from parent</span></span>
<span></span>
<span><span class="co">// Check that you&#39;re not trying to create a hardened child public key (extended public keys cannot access public keys of hardened extended private key children)</span></span>
<span><span class="kw">if</span> <span class="ot">(</span><span class="kw">$i</span> &gt;= <span class="dv">2</span>**<span class="dv">31</span><span class="ot">)</span> {</span>
<span>    <span class="kw">throw</span> <span class="kw">new</span> <span class="kw">Exception</span><span class="ot">(</span><span class="st">&quot;Cannot create a hardened extended child public key. Hardened children of extended private key are private.&quot;</span><span class="ot">);</span></span>
<span>}</span>
<span></span>
<span><span class="co">// Put data (parent public key + i) and chain code through HMAC-SHA512</span></span>
<span><span class="kw">$hmac</span> = <span class="fu">hash_hmac</span><span class="ot">(</span><span class="st">&quot;sha512&quot;</span><span class="ot">,</span> <span class="fu">pack</span><span class="ot">(</span><span class="st">&quot;H*&quot;</span><span class="ot">,</span> <span class="kw">$parent_public_key</span><span class="ot">)</span>.<span class="fu">pack</span><span class="ot">(</span><span class="st">&quot;N&quot;</span><span class="ot">,</span> <span class="kw">$i</span><span class="ot">),</span> <span class="fu">hex2bin</span><span class="ot">(</span><span class="kw">$parent_chain_code</span><span class="ot">));</span> <span class="co">// same data as when creating normal child extended private key</span></span>
<span><span class="kw">$left</span> = <span class="fu">substr</span><span class="ot">(</span><span class="kw">$hmac</span><span class="ot">,</span> <span class="dv">0</span><span class="ot">,</span> <span class="dv">64</span><span class="ot">);</span></span>
<span><span class="kw">$right</span> = <span class="fu">substr</span><span class="ot">(</span><span class="kw">$hmac</span><span class="ot">,</span> <span class="dv">64</span><span class="ot">);</span></span>
<span></span>
<span><span class="co">// Child chain code is right side of HMAC-SHA512 </span></span>
<span><span class="co">// m -------- p</span></span>
<span><span class="co">//            |</span></span>
<span><span class="co">//            |p/0 (chain code)</span></span>
<span><span class="kw">$child_chain_code</span> = <span class="kw">$right</span><span class="ot">;</span></span>
<span><span class="kw">echo</span> <span class="st">&quot;child_chain_code:   </span><span class="kw">$child_chain_code</span><span class="st">&quot;</span>.<span class="kw">PHP_EOL</span><span class="ot">;</span></span>
<span></span>
<span><span class="co">// Check child chain code is valid (not greater or equal to than the number of points on the curve)</span></span>
<span><span class="kw">if</span> <span class="ot">(</span><span class="fu">hexdec</span><span class="ot">(</span><span class="kw">$child_chain_code</span><span class="ot">)</span> &gt;= <span class="dv">115792089237316195423570985008687907852837564279074904382605163141518161494337</span><span class="ot">)</span> {</span>
<span>    <span class="kw">throw</span> <span class="kw">new</span> <span class="kw">Exception</span><span class="ot">(</span><span class="st">&quot;Child chain code is greater than or equal to the order of the elliptic curve. Try next index.&quot;</span><span class="ot">);</span></span>
<span>}</span>
<span></span>
<span><span class="co">// Calculate child public key: point(parent public key) + hmac left</span></span>
<span><span class="co">// m -------- p</span></span>
<span><span class="co">//            |</span></span>
<span><span class="co">//            |p/0 (pub)</span></span>
<span></span>
<span><span class="co">// point (parent public key)</span></span>
<span><span class="kw">$context</span> = secp256k1_context_create<span class="ot">(</span><span class="kw">SECP256K1_CONTEXT_SIGN</span> | <span class="kw">SECP256K1_CONTEXT_VERIFY</span><span class="ot">);</span>                 <span class="co">// set curve context</span></span>
<span><span class="kw">$point_public</span> = <span class="kw">null</span><span class="ot">;</span> secp256k1_ec_pubkey_parse<span class="ot">(</span><span class="kw">$context</span><span class="ot">,</span> <span class="kw">$point_public</span><span class="ot">,</span> <span class="fu">hex2bin</span><span class="ot">(</span><span class="kw">$parent_public_key</span><span class="ot">));</span>  <span class="co">// point(parent public key)</span></span>
<span></span>
<span><span class="co">// add point(hmac left) to point(parent public key)</span></span>
<span>secp256k1_ec_pubkey_tweak_add<span class="ot">(</span><span class="kw">$context</span><span class="ot">,</span> <span class="kw">$point_public</span><span class="ot">,</span> <span class="fu">hex2bin</span><span class="ot">(</span><span class="kw">$left</span><span class="ot">));</span> <span class="co">// add hmac left to the parent public key point</span></span>
<span><span class="kw">$add</span> = <span class="st">&#39;&#39;</span><span class="ot">;</span> secp256k1_ec_pubkey_serialize<span class="ot">(</span><span class="kw">$context</span><span class="ot">,</span> <span class="kw">$add</span><span class="ot">,</span> <span class="kw">$point_public</span><span class="ot">,</span> <span class="kw">SECP256K1_EC_COMPRESSED</span><span class="ot">);</span> <span class="co">// serialize to compressed key</span></span>
<span><span class="kw">$child_public_key</span> = <span class="fu">unpack</span><span class="ot">(</span><span class="st">&quot;H*&quot;</span><span class="ot">,</span> <span class="kw">$add</span><span class="ot">)[</span><span class="dv">1</span><span class="ot">];</span></span>
<span><span class="kw">echo</span> <span class="st">&quot;child_public_key:   </span><span class="kw">$child_public_key</span><span class="st">&quot;</span>.<span class="kw">PHP_EOL</span><span class="ot">;</span></span>
<span><span class="kw">echo</span> <span class="kw">PHP_EOL</span><span class="ot">;</span></span>
<span></span>
<span><span class="co">// ----------------------</span></span>
<span><span class="co">// Serialize Extended Key </span></span>
<span><span class="co">// ----------------------</span></span>
<span><span class="kw">$parent_public_key</span> = <span class="kw">$master_public_key</span><span class="ot">;</span> <span class="co">// needed for creating fingerprint</span></span>
<span></span>
<span><span class="kw">$chain_code</span> = <span class="kw">$child_chain_code</span><span class="ot">;</span></span>
<span><span class="kw">$private_key</span> = <span class="kw">$child_private_key</span><span class="ot">;</span></span>
<span></span>
<span><span class="co">// | version | depth  | parent fingerprint |  index  | chain code | key (private or public) |</span></span>
<span><span class="co">// | 4 bytes | 1 byte |      4 bytes       | 4 bytes |  32 bytes  |        33 bytes         |  = 78 bytes</span></span>
<span></span>
<span><span class="kw">function</span> create_fingerprint<span class="ot">(</span><span class="kw">$parent_public_key</span><span class="ot">)</span> {</span>
<span>    <span class="kw">$hash160</span> = <span class="fu">hash</span><span class="ot">(</span><span class="st">&quot;ripemd160&quot;</span><span class="ot">,</span> <span class="fu">hash</span><span class="ot">(</span><span class="st">&quot;sha256&quot;</span><span class="ot">,</span> <span class="fu">hex2bin</span><span class="ot">(</span><span class="kw">$parent_public_key</span><span class="ot">),</span> <span class="kw">true</span><span class="ot">));</span> <span class="co">// hash160 the parent public key</span></span>
<span>    <span class="kw">return</span> <span class="fu">substr</span><span class="ot">(</span><span class="kw">$hash160</span><span class="ot">,</span> <span class="dv">0</span><span class="ot">,</span> <span class="dv">8</span><span class="ot">);</span> <span class="co">// return first 4 bytes (8 hex characters)</span></span>
<span>}</span>
<span></span>
<span><span class="kw">$version</span>     = <span class="st">&quot;0488ade4&quot;</span><span class="ot">;</span>               <span class="co">// 0488ade4 = private (xprv), 0488b21e = public (xpub)</span></span>
<span><span class="kw">$depth</span>       = <span class="st">&quot;01&quot;</span><span class="ot">;</span>                     <span class="co">// how many times this child has been derived from master key (0 = master key)</span></span>
<span><span class="kw">$fingerprint</span> = create_fingerprint<span class="ot">(</span><span class="kw">$parent_public_key</span><span class="ot">);</span> <span class="co">// fingerprint of parent key - first 4 bytes of hash160(parent public key) (00000000 = master key)</span></span>
<span><span class="kw">$index</span>       = <span class="st">&quot;00000000&quot;</span><span class="ot">;</span>               <span class="co">// the index of this child key from the parent (4 byte hexadecimal string)</span></span>
<span><span class="kw">$chain_code</span>  = <span class="kw">$chain_code</span><span class="ot">;</span>              <span class="co">// chain code for this key</span></span>
<span><span class="kw">$key</span>         = <span class="st">&quot;00&quot;</span>.<span class="kw">$private_key</span><span class="ot">;</span>        <span class="co">// private or public key you want to create a serialized extended key for (prepend 0x00 for private)</span></span>
<span></span>
<span><span class="co">// Serialize the data</span></span>
<span><span class="kw">$serialized</span> = <span class="kw">$version</span>.<span class="kw">$depth</span>.<span class="kw">$fingerprint</span>.<span class="kw">$index</span>.<span class="kw">$chain_code</span>.<span class="kw">$key</span><span class="ot">;</span></span>
<span></span>
<span><span class="co">// Create a checksum for it (hash twice through sha256 and take first 4 bytes)</span></span>
<span><span class="kw">$checksum</span> = <span class="fu">substr</span><span class="ot">(</span><span class="fu">hash</span><span class="ot">(</span><span class="st">&quot;sha256&quot;</span><span class="ot">,</span> <span class="fu">hash</span><span class="ot">(</span><span class="st">&quot;sha256&quot;</span><span class="ot">,</span> <span class="fu">hex2bin</span><span class="ot">(</span><span class="kw">$serialized</span><span class="ot">),</span> <span class="kw">true</span><span class="ot">)),</span> <span class="dv">0</span><span class="ot">,</span> <span class="dv">8</span><span class="ot">);</span></span>
<span></span>
<span><span class="co">// Base58 encode the serialized+checksum</span></span>
<span><span class="kw">function</span> base58_encode<span class="ot">(</span><span class="kw">$hex</span><span class="ot">)</span>{</span>
<span>    <span class="kw">$base58chars</span> = <span class="st">&quot;123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz&quot;</span><span class="ot">;</span></span>
<span></span>
<span>    <span class="kw">if</span> <span class="ot">(</span><span class="fu">strlen</span><span class="ot">(</span><span class="kw">$hex</span><span class="ot">)</span> == <span class="dv">0</span><span class="ot">)</span> {</span>
<span>        <span class="kw">return</span> <span class="st">&#39;&#39;</span><span class="ot">;</span></span>
<span>    }</span>
<span></span>
<span>    <span class="co">// Convert the hex string to a base10 integer</span></span>
<span>    <span class="kw">$num</span> = <span class="fu">gmp_strval</span><span class="ot">(</span><span class="fu">gmp_init</span><span class="ot">(</span><span class="kw">$hex</span><span class="ot">,</span> <span class="dv">16</span><span class="ot">),</span> <span class="dv">58</span><span class="ot">);</span></span>
<span></span>
<span>    <span class="co">// Check that number isn&#39;t just 0 - which would be all padding.</span></span>
<span>    <span class="kw">if</span> <span class="ot">(</span><span class="kw">$num</span> != <span class="st">&#39;0&#39;</span><span class="ot">)</span> {</span>
<span>        <span class="kw">$num</span> = <span class="fu">strtr</span><span class="ot">(</span><span class="kw">$num</span><span class="ot">,</span> <span class="st">&#39;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuv&#39;</span><span class="ot">,</span> <span class="kw">$base58chars</span><span class="ot">);</span></span>
<span>    }</span>
<span>    <span class="kw">else</span> {</span>
<span>        <span class="kw">$num</span> = <span class="st">&#39;&#39;</span><span class="ot">;</span></span>
<span>    }</span>
<span></span>
<span>    <span class="co">// Pad the leading 1&#39;s</span></span>
<span>    <span class="kw">$pad</span> = <span class="st">&#39;&#39;</span><span class="ot">;</span></span>
<span>    <span class="kw">$n</span> = <span class="dv">0</span><span class="ot">;</span></span>
<span>    <span class="kw">while</span> <span class="ot">(</span><span class="fu">substr</span><span class="ot">(</span><span class="kw">$hex</span><span class="ot">,</span> <span class="kw">$n</span><span class="ot">,</span> <span class="dv">2</span><span class="ot">)</span> == <span class="st">&#39;00&#39;</span><span class="ot">)</span> {</span>
<span>        <span class="kw">$pad</span> .= <span class="st">&#39;1&#39;</span><span class="ot">;</span></span>
<span>        <span class="kw">$n</span> += <span class="dv">2</span><span class="ot">;</span></span>
<span>    }</span>
<span></span>
<span>    <span class="kw">return</span> <span class="kw">$pad</span> . <span class="kw">$num</span><span class="ot">;</span></span>
<span>}</span>
<span></span>
<span><span class="kw">$master_extended_private_key</span> = base58_encode<span class="ot">(</span><span class="kw">$serialized</span>.<span class="kw">$checksum</span><span class="ot">);</span></span>
<span><span class="kw">echo</span> <span class="st">&quot;master_extended_private_key: </span><span class="kw">$master_extended_private_key</span><span class="st">&quot;</span>.<span class="kw">PHP_EOL</span><span class="ot">;</span></span></code></pre>

</div>

</div>
</div>
</body>
</html>
